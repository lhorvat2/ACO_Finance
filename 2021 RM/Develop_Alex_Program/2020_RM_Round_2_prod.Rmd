---
title: "Prescreen_revenue_production_check"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)


#6/15/2020
rm(list = ls())
library(dplyr)
library(readxl)
library(tidyr)
library(stringr)
library(readr)
library(lubridate)
library(reticulate)
```






```{r Set up tracks, read in current repayment amounts}

TRACK <- c("1", "2", "3", "1+", "A", "B", "C", "D", "E", "EN")
RISK <- c("No", "Yes", "Yes", "Yes", "No", "No", "Yes", "Yes", "Yes", "Yes")

trackRisk <- as_tibble(cbind(TRACK, RISK))

#actual repayment. will not change in any round
repay <- read_excel("Z:\\finance\\participant revenue and expenditures\\2021 Cycle\\Inputs\\Round 1\\0_Repayment Mechanism Tracker_consolidated.xlsx") %>%
  select(ACO = 1, REPAY_CURRENT) %>% group_by(ACO) %>% slice(1)

```




```{r Read in TIN/CCN expenditure and revenue files}

#actual expends/revenue. will not change in any round until final
qaTinExpends <- as_tibble(read_csv("Z:\\pgm output\\ACO-3427 (2021 TIN First TIN Level Expenditures)\\TI00.MSSP.GX9V.SASRNR51.TINEXP.csv")) %>%
  mutate_all(as.character) %>%
  mutate(TIN = str_pad(TIN, 9, side = c("left"), pad = "0")) %>%
  #i know this sucks. r is stupid
  mutate(ESRD_EXP_PER_BENE = as.numeric(ESRD_EXP_PER_BENE),
         ESRD_PY = as.numeric(ESRD_PY),
         DIS_EXP_PER_BENE = as.numeric(DIS_EXP_PER_BENE),
         DIS_PY = as.numeric(DIS_PY),
         AGND_EXP_PER_BENE = as.numeric(AGND_EXP_PER_BENE),
         AGND_PY = as.numeric(AGND_PY),
         AGDU_EXP_PER_BENE = as.numeric(AGDU_EXP_PER_BENE),
         AGDU_PY = as.numeric(AGDU_PY),
         TOT_AB = as.numeric(TOT_AB))

qaCcnExpends <- as_tibble(read_csv("Z:\\pgm output\\ACO-3427 (2021 TIN First TIN Level Expenditures)\\TI00.MSSP.GX9V.SASRNR51.CCNEXP.csv")) %>%
  mutate_all(as.character) %>%
  mutate(CCN = str_pad(CCN, 6, side = c("left"), pad = "0")) %>%
  mutate(ESRD_EXP_PER_BENE = as.numeric(ESRD_EXP_PER_BENE),
         ESRD_PY = as.numeric(ESRD_PY),
         DIS_EXP_PER_BENE = as.numeric(DIS_EXP_PER_BENE),
         DIS_PY = as.numeric(DIS_PY),
         AGND_EXP_PER_BENE = as.numeric(AGND_EXP_PER_BENE),
         AGND_PY = as.numeric(AGND_PY),
         AGDU_EXP_PER_BENE = as.numeric(AGDU_EXP_PER_BENE),
         AGDU_PY = as.numeric(AGDU_PY),
         TOT_AB = as.numeric(TOT_AB))


qaTinRevenue <- as_tibble(read_csv("Z:\\pgm output\\ACO-2648 TIN and CCN Revenues\\TI00.MSSP.D4MZ.P7A19E0.PROF1.CSV")) %>%
  mutate(TIN = as.character(TIN),
         TIN = str_pad(TIN, 9, side = c("left"), pad = "0"))


qaCcnRevenue <- as_tibble(read_csv("Z:\\pgm output\\ACO-2648 TIN and CCN Revenues\\TI00.MSSP.D4MZ.P7A19E0.INST2.CSV")) %>%
  mutate(CCN = as.character(CCN),
         CCN = str_pad(CCN, 6, side = c("left"), pad = "0"))

```





```{r Read in crosswalk files}

qaAcoTin = as_tibble(haven::read_sas("Y:\\data\\jsciandra\\Prescreening\\2021\\G2\\batch_g2_tin_20200827.sas7bdat")) %>%
  select(ACO = ACO_ID, TIN, PROGRAM_YEAR = Program_Year, TRACK = ACO_Track, Latest_Agreement_Start_Date = Latest_Agreement_Start_Date, Renewal_Effective_Date = Renewal_Effective_Date, ACO_START_DATE = ACO_Start_Date, INTO_RISK = Into_Risk) %>%
  #doing this to drop all leading zeroes up front so everything merges nicely
  mutate(TIN = as.character(TIN),
         TIN = str_pad(TIN, 9, side = c("left"), pad = "0"))


#some validations
sum(is.na(qaAcoTin$Latest_Agreement_Start_Date))
sum(is.na(qaAcoTin$Renewal_Effective_Date))
sum(is.na(qaAcoTin$ACO_Current_Start_Date))





# Comparisons are much faster with Latest Agreement Start Date as a character
#will have to be edited if not using SAS input from Keith
qaAcoTin$Latest_Agreement_Start_Date = as.character(qaAcoTin$Latest_Agreement_Start_Date)
qaAcoTin$ACO_START_DATE = as.character(qaAcoTin$ACO_START_DATE)

unique(qaAcoTin$Latest_Agreement_Start_Date)
unique(qaAcoTin$ACO_START_DATE)


acoData <- qaAcoTin %>% distinct(ACO, .keep_all = TRUE) %>% select(-TIN)


#ACO/TIN/CCN crosswalk
qaAcoTinCcn <- as_tibble(haven::read_sas("Y:\\data\\mmills\\4_prescreening\\2021\\BatchG2\\ccn_list\\g2ccn20200828.sas7bdat")) %>%
  filter(use_record == 1) %>%
  select(ACO , TIN, CCN) %>%
  mutate(ACO = as.character(ACO),
         TIN = as.character(TIN),
         CCN = as.character(CCN),
         TIN = str_pad(TIN, 9, side = c("left"), pad = "0"),
         CCN = str_pad(CCN, 6, side = c("left"), pad = "0")) %>% 
  #this is exerimental 
  distinct(ACO, TIN, CCN)

qaAcoTinCcn$CCN_digits = nchar(qaAcoTinCcn$CCN)
qaAcoTinCcn$TIN = gsub("'","", qaAcoTinCcn$TIN)



```

```{r Read in new inputs for 2020}

# Track 1+ Current Composition Status
Track_1_plus_status = read_csv("Z:\\finance\\participant revenue and expenditures\\2021 Cycle\\Inputs\\Round 1\\Track_1+.csv")


```



```{r 1a }
#1.	Create an ACO/TIN/CCN-level file with assigned beneficiaries, expenditures, and revenues (from claims).

#  a.	Starting with the CCN-level expenditure file, do the following:
#    i.	Calculate TOT_EXP as ∑ ([status]_EXP_PER_BENE * [status]_PY)
#      1.	Note that for some records one or more of the [status]_EXP_PER_BENE or [status]_PY variables may be missing. Ensure that TOT_EXP is not being set to missing in these cases.
#    ii.	Keep only the following variables: CCN, TOT_AB, TOT_EXP



qaCcn <- qaCcnExpends %>%
  #replace NA in expenditure columns with 0 in order to avoid missing averages
  replace_na(list(ESRD_EXP_PER_BENE = 0, DIS_EXP_PER_BENE = 0, AGDU_EXP_PER_BENE = 0, AGND_EXP_PER_BENE = 0)) %>%
  # i. 
  mutate(TOT_EXP = (ESRD_EXP_PER_BENE * ESRD_PY) + (DIS_EXP_PER_BENE * DIS_PY) + (AGDU_EXP_PER_BENE * AGDU_PY) + (AGND_EXP_PER_BENE * AGND_PY)) %>%
  # ii. 
  select(CCN, TOT_AB, TOT_EXP)

qaCcn %>% write_excel_csv("Z:\\staff folders\\adraine\\Repayment Mechanism\\Step 6 Validation\\Step_1a_lrh.csv")



```



```{r 1b}
#b. Merge the modified CCN-level expenditure data set from Step (1a) onto the ACO/TIN/CCN crosswalk, by CCN
# i. If a CCN is the CCN-level expenditure file but not the ACO/TIN/CCN crosswalk, drop the record.
# ii. If the CCN is in the ACO/TIN/CCN crosswalk but not the CCN-level expenditure file, keep the record and set TOT_AB and TOT_EXP equal to 0.


qaCcnMerged <- qaAcoTinCcn %>%
  select(ACO, TIN, CCN) %>%
  #i.
  left_join(qaCcn, by = c("CCN")) %>%
  #ii.
  replace_na(list(TOT_AB = 0, TOT_EXP = 0))



qaCcnMerged %>% write_excel_csv("Z:\\staff folders\\adraine\\Repayment Mechanism\\Step 6 Validation\\Step_1b_lrh.csv")

```


```{r 1c}
# c.	Merge the CCN-level revenue file (from claims) onto the ACO/TIN/CCN level data set from Step (1b).
#   i.	If a CCN is in the CCN-level revenue file (from claims) but not the ACO/TIN/CCN-level data set from Step (1b), drop the record.
#   ii.	If a CCN is in the ACO/TIN/CCN-level data set from Step (1b) but not the CCN-level revenue file, keep the record and set CCN_TOT_REV equal to 0.
#   iii.	Rename CCN_TOT_REV as TOT_REV
#   iv.	The resulting data set should have 1 record for each ACO/TIN/CCN combination in the original ACO/TIN/CCN crosswalk.

qaCcnMerged <- qaCcnMerged %>%
  #i.
  left_join(qaCcnRevenue, by = c("CCN")) %>%
  #ii.
  replace_na(list(CCN_TOT_REV = 0)) %>%
  #iii.
  select(ACO, TIN, CCN, TOT_AB, TOT_EXP, TOT_REV = CCN_TOT_REV)



#qaCcnMerged %>% write_excel_csv("Z:\\staff folders\\adraine\\Repayment Mechanism\\Step 6 Validation\\Step_1_lrh.csv")

```


```{r 2a}
#2.	Create a new ACO-level file using the ACO/TIN/CCN-level data set created in Step (1).
# a.	Starting with the data set created in Step (1):
#   i.	Drop the TIN variable.
#   ii.	Drop any records with duplicative ACO/CCN combinations.
#     1. For example, if there are two records where ACO_ID = A1111 and CCN = 111111, drop one of these records.
#     2.	The purpose of this step is to ensure that if a CCN is linked to multiple TINs within the same ACO, the CCN’s assigned beneficiaries, expenditures, and revenue will only be counted once when calculating ACO-level values.


qaAcoCcnMerged <- qaCcnMerged %>%
  #i.
  select(-TIN) %>%
  #ii.
  distinct(ACO, CCN, .keep_all = TRUE)





```


```{r 2b}
# b.	Using the modified data set from Step (2a), create a new data set by calculating the following for each ACO_ID:
#   i.	TOT_AB = sum TOT_AB
#   ii.	TOT_EXP = sum TOT_EXP
#   iii.	TOT_REV = sum TOT_REV
#   iv. NUM_CCN = number of CCNs per ACO
#   v.	The resulting data set should have 1 record for each ACO in the original ACO/TIN/CCN crosswalk.


qaAcoFromCcn <- qaAcoCcnMerged %>%
  group_by(ACO) %>%
  summarize(
            #i
            TOT_AB = sum(TOT_AB),
            #ii
            TOT_EXP = sum(TOT_EXP),
            #iii
            TOT_REV = sum(TOT_REV),
            #iv
            num_ccn=n(),
            TOT_EXP_CCN = sum(TOT_EXP),
            TOT_REV_CCN = sum(TOT_REV))


#qaAcoFromCcn %>% write_excel_csv("Z:\\staff folders\\adraine\\Repayment Mechanism\\Step 6 Validation\\Step_2_lrh.csv")


```

```{r 3}

# 3.	Create an ACO/TIN level file with assigned beneficiaries, expenditures, and revenues (from claims).
#   a.	Starting with the TIN-level expenditure file, do the following:
#     i.	Calculate TOT_EXP as sum ([status]_EXP_PER_BENE * [status]_PY)
#       1.	Note that for some records one or more of the [status]_EXP_PER_BENE or [status]_PY variables may be missing. Ensure that TOT_EXP is not being set to missing in these cases.
#     ii.	Keep only the following variables: TIN, TOT_AB, TOT_EXP

qaAcoTinSummed <- qaTinExpends %>%
  #ensure missings dont make average missing
  replace_na(list(ESRD_EXP_PER_BENE = 0, DIS_EXP_PER_BENE = 0, AGDU_EXP_PER_BENE = 0, AGND_EXP_PER_BENE = 0)) %>%
  #i.
  mutate(TOT_EXP = (ESRD_EXP_PER_BENE * ESRD_PY) + (DIS_EXP_PER_BENE * DIS_PY) + (AGDU_EXP_PER_BENE * AGDU_PY) + (AGND_EXP_PER_BENE * AGND_PY)) %>%
  #ii.
  select(TIN, TOT_AB, TOT_EXP)



```


```{r 3b}
# b.	Merge the modified TIN-level expenditure data set from Step (3a) onto the ACO/TIN crosswalk, by TIN
#   i.	If a TIN is the TIN-level expenditure file but not the ACO/TIN crosswalk, drop the record.
#   ii.	If the TIN is in the ACO/TIN crosswalk but not the TIN-level expenditure file, keep the record and set TOT_AB and TOT_EXP equal to 0.


qaAcoTinMerged <- qaAcoTin %>%
  #i.
  left_join(qaAcoTinSummed, by = c("TIN")) %>%
  #ii.
  replace_na(list(TOT_AB = 0, TOT_EXP = 0))



```


```{r 3c}

# c.	Merge the TIN-level revenue file (from claims) onto the ACO/TIN-level data set from Step (3b).
#   i.	If a TIN is in the TIN-level revenue file (from claims) but not the ACO/TIN-level data set from Step (3b), drop the record.
#   ii.	If a TIN is in the ACO/TIN-level data set from Step (3b) but not the TIN-level revenue file (from claims), keep the record and set TIN_TOT_REV equal to 0.
#   iii.	Rename TIN_TOT_REV as TOT_REV_FROM_CLM
#   iv.	The resulting data set should have 1 record for each ACO/TIN combination in the original ACO/TIN crosswalk.
#   v. Generate a variable called NUM_TIN which is the number of TINs per ACO


qaAcoTinMerged <- qaAcoTinMerged %>%
  #i.
  left_join(qaTinRevenue, by = c("TIN")) %>%
  #ii.
  replace_na(list(TIN_TOT_REV = 0)) %>%
  #iii.
  select(everything(), TOT_REV = TIN_TOT_REV) %>% 
  group_by(ACO) %>% 
  #iv
  mutate(num_TIN = n())

#qaAcoTinMerged %>% write_excel_csv("Z:\\staff folders\\adraine\\Repayment Mechanism\\Step 6 Validation\\Step_3_lrh.csv")


```



```{r 4a & 4b }
# 4.	Create a new ACO/TIN-level data set that incorporates both CCN-level and TIN-level assigned beneficiaries, expenditures, and revenues (from claims).
#   a.	Stack the data sets created in Step (1) and Step (3).
#   b.	Using the stacked data set, create a new data set by calculating the following for each ACO/TIN combination:
#     i.	TOT_AB = sum TOT_AB
#     ii.	TOT_EXP = sum TOT_EXP
#     iii.	TOT_REV_FROM_CLM = sum TOT_REV_FROM_CLM
#     iv.	The resulting should have 1 record for each ACO/TIN combination in the original ACO/TIN crosswalk.


qaAcoTinAll <- full_join(qaAcoTinMerged, qaCcnMerged) %>%
  #b.
  group_by(ACO, TIN) %>%
  summarize(
    #i.
    TOT_AB = sum(TOT_AB),
    #ii.
    TOT_EXP = sum(TOT_EXP),
    #iii.
    TOT_REV = sum(TOT_REV)
  )



test_qaCcnMerged = qaCcnMerged %>% filter(TIN == "270335043")
test_qaAcoTinMerged = qaAcoTinMerged %>% filter(TIN == "270335043")

#qaAcoTinAll %>% write_excel_csv("Z:\\staff folders\\adraine\\Repayment Mechanism\\Step 6 Validation\\Step_4_lrh.csv")

```

```{r 5}

# 5.	Create a new ACO-level data set that incorporates both CCN-level and TIN-level assigned beneficiaries, expenditures, and revenues (from claims).
#   a.	Stack the data sets created in Step (2) and Step (3).
#   b.	Using the stacked data set, create a new data set by calculating the following for each ACO_ID:
#     i.	TOT_AB = sum TOT_AB
#     ii.	TOT_EXP = sum TOT_EXP
#     iii.	TOT_REV = sum TOT_REV
#     iv.	The resulting data set should have 1 record for each ACO in the original ACO/TIN crosswalk.


qaAcoTinMerged = qaAcoTinMerged %>% 
  group_by(ACO) %>% 
  mutate(
    TOT_EXP_TIN = sum(TOT_EXP),
    TOT_REV_TIN = sum(TOT_REV)
  )


#a
qaAcoAll <- full_join(qaAcoFromCcn, qaAcoTinMerged) %>%
  #b.
  group_by(ACO) %>%
  summarize(
    #i.
    TOT_AB = sum(TOT_AB),
    #ii.
    TOT_EXP = sum(TOT_EXP),
    #iii.
    TOT_REV = sum(TOT_REV),
    num_TIN = max(num_TIN,na.rm=TRUE),
    num_CCN = max(num_ccn,na.rm=TRUE),
    
    TOT_EXP_TIN = max(TOT_EXP_TIN, na.rm = TRUE),
    TOT_REV_TIN = max(TOT_REV_TIN, na.rm = TRUE),
    TOT_EXP_CCN = max(TOT_EXP_CCN, na.rm = TRUE),
    TOT_REV_CCN = max(TOT_REV_CCN, na.rm = TRUE)
  ) 

qaAcoAll$TOT_EXP_CCN[qaAcoAll$num_CCN == -Inf] = 0
qaAcoAll$TOT_REV_CCN[qaAcoAll$num_CCN == -Inf] = 0
qaAcoAll$num_CCN[qaAcoAll$num_CCN == -Inf] = 0


#qaAcoAll %>% write_excel_csv("Z:\\staff folders\\adraine\\Repayment Mechanism\\Step 6 Validation\\Step_5_lrh.csv")

####################################################################################################################### INTERMEDIATE DATASET ##############################################################################################################
####################################################################################################################### INTERMEDIATE DATASET ##############################################################################################################
####################################################################################################################### INTERMEDIATE DATASET ##############################################################################################################
####################################################################################################################### INTERMEDIATE DATASET ##############################################################################################################
####################################################################################################################### INTERMEDIATE DATASET ##############################################################################################################
####################################################################################################################### INTERMEDIATE DATASET ##############################################################################################################
####################################################################################################################### INTERMEDIATE DATASET ##############################################################################################################
####################################################################################################################### INTERMEDIATE DATASET ##############################################################################################################
####################################################################################################################### INTERMEDIATE DATASET ##############################################################################################################


```

```{r 6}
# 6.	Create a combined ACO-level and ACO/TIN-level data set.
#a.	Stack ACO-level data set created in Step (4) and ACO/TIN-level data set created in Step (5).
#b.	For records coming from the ACO-level data set, set TIN equal to "Total/Average".
#c.	Create a new variable METHODOLOGY set equal to "Benchmark-based" for all records.
#e.	Merge on other ACO-level variables, by ACO_ID
      #i.	TRACK (From ACO/TIN crosswalk)
      #ii.	PROGRAM_YEAR (From ACO/TIN crosswalk)
      #iii.	Latest_Agreement_Start_Date (From ACO/TIN crosswalk)
      #iv.	Renewal_Effective_Date (From ACO/TIN crosswalk)
      #v.	RISK (standalone input)
      #vi.	REPAY_CURRENT (standalone input)
                #1.	If missing in ACO-level dataset, set to missing
      #vii.	TRACK_1+_CURRENT_COMPOSITION (standalone input)
                #1.	IF TRACK_1+_CURRENT_COMPOSITION is missing in ACO-level dataset, set to missing

  #a
qaAllBnchmk <- full_join(qaAcoTinAll, 
                   #b
                   mutate(qaAcoAll, TIN = "Total/Average")) %>%
  #c
  mutate(METHODOLOGY = "Benchmark-based") %>%
  #e i, ii, iii
  left_join(acoData, by = c("ACO")) %>%
  #e v
  left_join(trackRisk) %>%
  #e vi
  left_join(repay,by=c("ACO"="ACO")) %>%
  # vii
  left_join(Track_1_plus_status,by=c("ACO"="ACO.ID")) %>% arrange(ACO, desc(TIN)) 


#qaAllBnchmk %>% write_excel_csv("Z:\\staff folders\\adraine\\Repayment Mechanism\\Step 6 Validation\\Step_6_lrh_0401.csv")



```


```{r 7}

# 7.	Create a duplicate version of data set created in Step (6).
#   a.	In this version, set METHODOLOGY equal to "Revenue-based".

qaAllRev <- as_tibble(qaAllBnchmk) %>%
  mutate(METHODOLOGY = "Revenue-based")


```

```{r 8}

# 8.	Stack the data sets from Step (6) and Step (7).
#   a.	The resulting data set will include two ACO-level records and two records for each ACO/TIN combination.

qaAll <- full_join(qaAllBnchmk, qaAllRev) %>%
  select(everything(), ASSIGNED = TOT_AB)
sum(is.na(qaAll$TRACK[qaAll$TIN != 'Total/Average']))

qaAll %>% group_by(TRACK, RISK) %>% count()

temp = qaAll %>% filter()

```


```{r 9a helper funcs}

#Helper functions for calculating dollars per beneficiary and projected dollers per bene


#	DOLLAR_PER_BENE:
      #1.	If ASSIGNED > 0 and METHODOLOGY = "Benchmark-based", DOLLAR_PER_BENE = TOT_EXP/ASSIGNED
      #2.	 If ASSIGNED > 0 and METHODOLOGY = "Revenue-based", DOLLAR_PER_BENE = TOT_REV/ASSIGNED
      #3.	If ASSIGNED = 0, DOLLAR_PER_BENE = missing
dollarPerBeneFn <- Vectorize(function(ASSIGNED, METHODOLOGY, TOT_EXP, TOT_REV){
  if(ASSIGNED > 0 & METHODOLOGY == "Benchmark-based"){
    return (TOT_EXP / ASSIGNED)
  }
  if (ASSIGNED > 0 & METHODOLOGY == "Revenue-based"){
    return (TOT_REV / ASSIGNED)
  }
  if (ASSIGNED == 0){return (NA)}
}
)


#	PROJ_DOLLAR_PER_BENE:
    #1.	If ASSIGNED > 0, PROJ_DOLLAR_PER_BENE = DOLLAR_PER_BENE * DOLLAR_TREND
    #2.	If ASSIGNED = 0, PROJ_DOLLAR_PER_BENE = missing
projDollPerBeneFn <- Vectorize(function(ASSIGNED, DOLLAR_PER_BENE, DOLLAR_TREND){
  if(ASSIGNED > 0){
    return(DOLLAR_PER_BENE * DOLLAR_TREND)
  }
  if(ASSIGNED == 0){
    return(NA)
  }
})


#	PROJ_TOT_DOLLAR:
    #1.	If METHODOLOGY = "Benchmark-based":
      #a.	If (0 < ASSIGNED * ASSG_GROWTH < 5000) and (TIN = "Total/Average"):
        #i.	PROJ_TOT_DOLLAR = PROJ_DOLLAR_PER_BENE * 5000
      #b.	Else:
        #i.	PROJ_TOT_DOLLAR = TOT_EXP * ASSG_GROWTH * DOLLAR_TREND
    #2.	If METHODOLOGY = "Revenue-based":
      #a.	If (0 < ASSIGNED * ASSG_GROWTH < 5000) and (TIN = "Total/Average"):
        #i.	PROJ_TOT_DOLLAR = PROJ_DOLLAR_PER_BENE * 5000
      #b.	Else:
        #i.	PROJ_TOT_DOLLAR = TOT_REV * ASSG_GROWTH * DOLLAR TREND
projTotDollFn <- Vectorize(function(ASSIGNED, ASSG_GROWTH, METHODOLOGY, TIN, TOT_EXP, TOT_REV, DOLLAR_TREND){
  if (METHODOLOGY == "Benchmark-based"){
    if(((ASSIGNED * ASSG_GROWTH) < 5000) & ((ASSIGNED * ASSG_GROWTH) > 0) & (TIN == "Total/Average")){
      return (TOT_EXP / ASSIGNED * 5000 * DOLLAR_TREND)
    } else{
      return(TOT_EXP * ASSG_GROWTH * DOLLAR_TREND)
    }
  }
  
  if (METHODOLOGY == "Revenue-based"){
    if(((ASSIGNED * ASSG_GROWTH) < 5000) & ((ASSIGNED * ASSG_GROWTH) > 0) & (TIN == "Total/Average")){
      return (TOT_REV / ASSIGNED * 5000 * DOLLAR_TREND)
    } else{
      return(TOT_REV * ASSG_GROWTH * DOLLAR_TREND)
    }
  }
})

#	PROJ_TOT_EXP:
    #1.	If (0 < ASSIGNED * ASSG_GROWTH < 5000) and (TIN = "Total/Average"):
      #a.	PROJ_TOT_EXP = (TOT_EXP / ASSIGNED) * DOLLAR_TREND * 5000 
    #2.	Else:
      #a.	PROJ_TOT_EXP = TOT_EXP * ASSG_GROWTH * DOLLAR TREND
projTotExpFn <- Vectorize(function(ASSIGNED, ASSG_GROWTH, TIN, TOT_EXP, DOLLAR_TREND){
  if(((ASSIGNED * ASSG_GROWTH) < 5000) & ((ASSIGNED * ASSG_GROWTH) > 0) & (TIN == "Total/Average")){
    return (TOT_EXP / ASSIGNED * 5000 * DOLLAR_TREND)
  } else{
    return(TOT_EXP * ASSG_GROWTH * DOLLAR_TREND)
  }
})



#	PROJ_TOT_REV:
    #1.	If (0 < ASSIGNED * ASSG_GROWTH < 5000) and (TIN = "Total/Average"):
      #a.	PROJ_TOT_REV = (TOT_REV / ASSIGNED) * DOLLAR_TREND * 5000 
    #2.	Else:
      #a.	PROJ_TOT_REV = TOT_REV * ASSG_GROWTH * DOLLAR TREND
projTotRevFn <- Vectorize(function(ASSIGNED, ASSG_GROWTH, TIN, TOT_REV, DOLLAR_TREND){
  if(((ASSIGNED * ASSG_GROWTH) < 5000) & ((ASSIGNED * ASSG_GROWTH) > 0) & (TIN == "Total/Average")){
    return (TOT_REV / ASSIGNED * 5000 * DOLLAR_TREND)
  } else{
    return(TOT_REV * ASSG_GROWTH * DOLLAR_TREND)
  }
})



#	TRACK_1+_LOSS_LIMIT_CHANGE
    #1.	If TRACK = "1+",  TRACK_1+_LOSS_LIMIT_CHANGE = "Track 1+ loss limit attestation changes have not yet occurred"
    #2.	Else 
      #TRACK_1+_LOSS_LIMIT_CHANGE = "Not Applicable"

Track_1plus_status_fn = Vectorize(function(TRACK){
  if(TRACK=="1+" ){
    return("Track 1+ loss limit attestation changes have not yet occurred")
  }
 else(
   return("Not Applicable")
 )  
})





#	REQ_PCT:
#  1.	If METHODOLOGY = “Benchmark-based”, REQ_PCT = 0.01
#  2.	If METHODOLOGY = “Revenue-based”, REQ_PCT = 0.02
reqPctFn <- Vectorize(function(METHODOLOGY){
  if(METHODOLOGY == "Benchmark-based"){return(0.01)}
  if(METHODOLOGY == "Revenue-based"){return(0.02)}
})




#	PROJ_ASSIGNED:
    #1.	If (0 < ASSIGNED * ASSG_GROWTH < 5000) and (TIN = "Total/Average"):
      #a.	PROJ_ASSIGNED = 5000
    #2.	Else:
      #a.	PROJ_ASSIGNED = ASSIGNED * ASSG_GROWTH
projAssignFn <- Vectorize(function(ASSIGNED, ASSG_GROWTH, TIN){
  projAssg <- ASSIGNED * ASSG_GROWTH
  
  if((0 < projAssg) & (projAssg < 5000) & (TIN == "Total/Average")){
    projAssg <- 5000
  }
  
  return(projAssg)
  
})





#	INITIAL_DETER_RM_AMT:
#1.	If ASSIGNED >0 & TRACK not in (1+,2,3):
    #a.	INITIAL_DETER_RM_AMT = Minimum of (FCST_RM_AMT_EXP, FCST_RM_AMT_REV)
#2.	If ASSIGNED >0 & TRACK = "1+" & TRACK_1_PLUS_CURRENT_COMPOSITION ="Benchmark":
    #a.	INITIAL_DETER_RM_AMT = FCST_RM_AMT_EXP
#3.	If ASSIGNED >0 & TRACK = "1+" & TRACK_1_PLUS_CURRENT_COMPOSITION ="Revenue":
    #a.	INITIAL_DETER_RM_AMT = Min(FCST_RM_AMT_REV, FCST_RM_AMT_EXP)
#4.	If ASSIGNED > 0 & TRACK in (2,3):
    #a.	INITIAL_DETER_RM_AMT = REPAY_CURRENT
#5.	If ASSIGNED = 0:
    #a.	INITIAL_DETER_RM_AMT = FCST_RM_AMT_REV
initDeterFn = Vectorize(function(ASSIGNED, TRACK, TRACK_1_PLUS_CURRENT_COMPOSITION, FCST_RM_AMT_EXP, FCST_RM_AMT_REV, REPAY_CURRENT, SCENARIO){
  INITIAL_DETER_RM_AMT = c()
  INITIAL_SCENARIO=c()
  if(ASSIGNED > 0 & !(TRACK %in% c("2", "1+", "3"))) {
  INITIAL_DETER_RM_AMT = min(FCST_RM_AMT_EXP, FCST_RM_AMT_REV)
  INITIAL_SCENARIO="non track 2,3,1+"
  }
  else if(ASSIGNED > 0 & TRACK == "1+" & TRACK_1_PLUS_CURRENT_COMPOSITION=="Benchmark"){
    INITIAL_DETER_RM_AMT = FCST_RM_AMT_EXP
    INITIAL_SCENARIO='1+, benchmark-based'
  }
  else if(ASSIGNED > 0 & TRACK == "1+" & TRACK_1_PLUS_CURRENT_COMPOSITION=="Revenue"){
    INITIAL_DETER_RM_AMT = min(FCST_RM_AMT_EXP, FCST_RM_AMT_REV)
    INITIAL_SCENARIO='1+, revenue-based'
  }  
  
  else if(ASSIGNED > 0 & TRACK %in% c("2", "3")){
    INITIAL_DETER_RM_AMT = REPAY_CURRENT
    INITIAL_SCENARIO='track 2,3'
  }
  else if(ASSIGNED==0){
    INITIAL_DETER_RM_AMT = FCST_RM_AMT_REV
    INITIAL_SCENARIO='0 assigned'
  }

  else{
    INITIAL_DETER_RM_AMT = FCST_RM_AMT_REV
    INITIAL_SCENARIO="Initial Error"
  }
  if (SCENARIO==TRUE){
    return(INITIAL_SCENARIO)
  }
  else{
    return(INITIAL_DETER_RM_AMT)
  }
 }
)






#	ACO_CATEGORY
#2.	If LATEST_AGREEMENT_START_DATE in (7/1/2019, 1/1/2020) & RISK = ”Yes”, ACO_CATEGORY= “basic_enhanced_two_sided”
  #a.	Note that these are ACOs that are continuing in an agreement period started July 1, 2019 or January 1, 2020 that will be participating in a two-sided risk model in 2021.

#3.	If LATEST_AGREEMENT_START_DATE in (1/1/2019, 1/1/2018) & RISK = ”Yes”, ACO_CATEGORY= “pre_basic_enhanced_two_sided”
  #a.	Note that these are ACOs that are continuing in an agreement period started January 1, 2018 or January 1, 2019 that will be participating in a two-sided risk model in 2021.

#4.	Otherwise ACO_CATEGORY = “non_two_sided”
  #a.	Note that these are ACOs that are applying for, or will be continuing in, a one-sided risk-model in 2021.



ACO_category_fn = Vectorize(function(Latest_Agreement_Start_Date, RISK, INTO_RISK){

  if(Latest_Agreement_Start_Date %in% c("2019-07-01", "2020-01-01") & RISK == "Yes" & INTO_RISK==1){
    return("basic_enhanced_into_two_sided")
  }
  else if(Latest_Agreement_Start_Date %in% c("2019-07-01", "2020-01-01") & RISK == "Yes" & INTO_RISK==0){
    return("basic_enhanced_maintain_two_sided")
  }  
  else if(Latest_Agreement_Start_Date %in% c("2019-01-01", "2018-01-01")  & RISK == "Yes"){
    return("pre_basic_enhanced_two_sided")
  }
  else{
    return("non_two_sided")
  }
})

#	HI_LOW_RATIO = PROJ_TOT_REV/PROJ_TOT_EXP
hiLowFn <- Vectorize(function(HI_LOW_RATIO){
  if(is.na(HI_LOW_RATIO) | HI_LOW_RATIO == Inf){return(NA)}
  if(HI_LOW_RATIO >= .35){return("High Revenue")}
  if(HI_LOW_RATIO < .35){return("Low Revenue")}
  
})



```



```{r 9a Calculate required payment amount, RM ACTION, and Threshold}
REQ_ACTION_THRESHOLD_fn = Vectorize(function(ACO_CATEGORY, RENEWING_ACO, REPAY_CURRENT, INITIAL_DETER_RM_AMT, TRACK, variable){
##  Basic/Enhanced Two Sided ACOs maintaining risk
#  .	Scenario 1: ACO_CATEGORY= "basic_enhanced_two_sided & REPAY_CURRENT is not missing & [(INITIAL_DETER_RM_AMT >= 1.5 x REPAY_CURRENT) OR (INITIAL_DETER_RM_AMT >= (1,000,000 + REPAY_CURRENT))]
      #o	REQ_RM_AMT = INITIAL_DETER_RM_AMT
      #o	RM_ACTION = "Contact your ACO Coordinator, ACO met threshold for potential RM increase"
      #o	THRESHOLD_EXCEEDED = "Yes (Increase)"

#.	Scenario 2:  ACO_CATEGORY= "basic_enhanced_two_sided & REPAY_CURRENT is not missing & (INITIAL_DETER_RM_AMOUNT < 1.5 x REPAY_CURRENT) & (INITIAL_DETER_RM_AMOUNT < (1,000,000 + REPAY_CURRENT))
      #o	REQ_RM_AMT = REPAY_CURRENT
      #o	RM_ACTION = "None. No change needed to existing RM amount."
      #o	THRESHOLD_EXCEEDED = "No"

#.	Scenario 3: ACO_CATEGORY= "basic_enhanced_two_sided & REPAY_CURRENT is missing
      #o	REQ_RM_AMT = INITIAL_DETER_RM_AMT
      #o	RM_ACTION = "Establish RM at required RM amount."
      #o	THRESHOLD_EXCEEDED = "Not Applicable"


    if(ACO_CATEGORY=="basic_enhanced_maintain_two_sided" & !is.na(REPAY_CURRENT) & (INITIAL_DETER_RM_AMT >= 1.5 * REPAY_CURRENT | INITIAL_DETER_RM_AMT >= (1E6 + REPAY_CURRENT))){
    REQ_RM_AMT = INITIAL_DETER_RM_AMT
    Message = "Contact your ACO Coordinator, ACO met threshold for potential RM increase"
    Threshold = "Yes (Increase)"
    REQ_SCENARIO = 'basic_enhanced_maintain_two_sided_1'
    }
    else if(ACO_CATEGORY=="basic_enhanced_maintain_two_sided" & !is.na(REPAY_CURRENT) & (INITIAL_DETER_RM_AMT < 1.5 * REPAY_CURRENT & INITIAL_DETER_RM_AMT < (1E6 + REPAY_CURRENT))){
    REQ_RM_AMT = REPAY_CURRENT
    Message = "None. No change needed to existing RM amount"
    Threshold = "No"
    REQ_SCENARIO = 'basic_enhanced_maintain_two_sided_2'
    }
    
    else if(ACO_CATEGORY=="basic_enhanced_maintain_two_sided" & is.na(REPAY_CURRENT) ){
    REQ_RM_AMT = INITIAL_DETER_RM_AMT
    Message = "Establish RM at required RM amount"
    Threshold = "Not Applicable"
    REQ_SCENARIO = 'basic_enhanced_maintain_two_sided_3'
    }
  
  
  
 ##  Basic/Enhanced Two Sided ACOs moving into risk
  #
  #•	Scenario 1: ACO_CATEGORY= “basic_enhanced_two_sided” 
    #o	REQ_RM_AMT = INITIAL_DETER_RM_AMT
    #o	RM_ACTION = "Establish RM at required amount"
    #o	THRESHOLD_EXCEEDED = "Yes (Increase)"
  
    else if(ACO_CATEGORY=="basic_enhanced_into_two_sided"){
    REQ_RM_AMT = INITIAL_DETER_RM_AMT
    Message = "Establish RM at required RM amount"
    Threshold = "Not Applicable"
    REQ_SCENARIO = 'basic_enhanced_into_two_sided_1'
    }
 
  
  
  
  
  
  
  ## Pre Basic/Enhanced two sided ACOs
#  .	Scenario 1: ACO_CATEGORY= "pre_basic_enhanced_two_sided" & TRACK="1+" 
      #o	REQ_RM_AMT = REPAY_CURRENT 
      #o	RM_ACTION = " None. No change needed to existing RM amount."
      #o	THRESHOLD_EXCEEDED = " Not Applicable"

#.	Scenario 2: ACO_CATEGORY = "pre_basic_enhanced_two_sided" & TRACK not equal to "1+" 
      #o	REQ_RM_AMT = REPAY_CURRENT
      #o	RM_ACTION = "None. No change needed to existing RM amount."
      #o	THRESHOLD_EXCEEDED = "Not Applicable"

    else if(ACO_CATEGORY=="pre_basic_enhanced_two_sided" & TRACK == "1+" ){
    REQ_RM_AMT = REPAY_CURRENT
    Message = "Track 1+ ACOs may need to increase RM Amount at a future date if loss-sharing limit changes for PY 2021"
    Threshold = "Not Applicable"
    REQ_SCENARIO = 'pre_july_two_sided_1'
    }

    else if(ACO_CATEGORY=="pre_basic_enhanced_two_sided" & TRACK!="1+" ){
    REQ_RM_AMT = REPAY_CURRENT
    Message = "For Information Only. No RM Adjustment Required"
    Threshold = "Not Applicable"
    REQ_SCENARIO = 'pre_july_two_sided_2'
    }      

  
  
  
  
  
  
  
## non risk ACOs    
#  .	Scenario 1: ACO_CATEGORY = "non_two_sided" 
      #o	  REQ_RM_AMT = INITIAL_DETER_RM_AMT
      #o	  RM_ACTION = "None. For Informational purposes only"
      #o	  THRESHOLD_EXCEEDED = "Not Applicable" 

   else if (ACO_CATEGORY=="non_two_sided"){
    REQ_RM_AMT = INITIAL_DETER_RM_AMT
    Message = "For Information Only. No RM Adjustment Required"
    Threshold = "Not Applicable" 
    REQ_SCENARIO = 'non_risk'
      
   }

  
## Should be none in this category    
  else{
    REQ_RM_AMT = NA
    Message = NA
    Threshold = NA
    REQ_SCENARIO = "not found"    
    
  }

#determine which metric output by function
  if(variable=='REQ_RM_AMT')
  return(REQ_RM_AMT)
 
else if(variable=='Message'){
  return(Message)
}
else if(variable=='Threshold'){
  return(Threshold)
}
else if(variable=='Req_Scenario'){
  return(REQ_SCENARIO)
}    
      
})




```


```{r 9a outputs }

#Generate output using helper functions
output <- qaAll %>%
  ungroup() %>%
  mutate(ASSG_GROWTH = 1.03136,
         
         PROJ_ASSIGNED = projAssignFn(ASSIGNED, ASSG_GROWTH, TIN),
         
         DOLLAR_PER_BENE = dollarPerBeneFn(ASSIGNED, METHODOLOGY, TOT_EXP, TOT_REV),
         
         DOLLAR_TREND = 1.09663,
         
         PROJ_DOLLAR_PER_BENE = projDollPerBeneFn(ASSIGNED, DOLLAR_PER_BENE, DOLLAR_TREND),
         
         PROJ_TOT_DOLLAR = projTotDollFn(ASSIGNED, ASSG_GROWTH, METHODOLOGY, TIN, TOT_EXP, TOT_REV, DOLLAR_TREND),
         
         PROJ_TOT_EXP = projTotExpFn(ASSIGNED, ASSG_GROWTH, TIN, TOT_EXP, DOLLAR_TREND),
         
         PROJ_TOT_REV = projTotRevFn(ASSIGNED, ASSG_GROWTH, TIN, TOT_REV, DOLLAR_TREND),
         
         REQ_PCT = reqPctFn(METHODOLOGY),
         
         FCST_RM_AMT = PROJ_TOT_DOLLAR * REQ_PCT,
         
         FCST_RM_AMT_EXP = PROJ_TOT_EXP * 0.01,
         
         FCST_RM_AMT_REV = PROJ_TOT_REV * 0.02,
         
         INITIAL_DETER_RM_AMT = initDeterFn(ASSIGNED, TRACK, TRACK_1_PLUS_CURRENT_COMPOSITION, FCST_RM_AMT_EXP, FCST_RM_AMT_REV, REPAY_CURRENT, SCENARIO=FALSE),
         
         INITIAL_SCENARIO = initDeterFn(ASSIGNED, TRACK, TRACK_1_PLUS_CURRENT_COMPOSITION, FCST_RM_AMT_EXP, FCST_RM_AMT_REV, REPAY_CURRENT, SCENARIO=TRUE),
         
         RENEWING_ACO =  if_else(ACO_START_DATE != "2021-01-01" & Latest_Agreement_Start_Date=="2021-01-01","Yes","No"),

         TRACK_1_PLUS_LOSS_LIMIT_CHANGE = Track_1plus_status_fn(TRACK),
         
         ACO_CATEGORY = ACO_category_fn(Latest_Agreement_Start_Date, RISK, INTO_RISK),
         
         REQ_RM_AMT = REQ_ACTION_THRESHOLD_fn(ACO_CATEGORY, RENEWING_ACO, REPAY_CURRENT, INITIAL_DETER_RM_AMT, TRACK,variable='REQ_RM_AMT'),
         
         RM_ACTION = REQ_ACTION_THRESHOLD_fn(ACO_CATEGORY, RENEWING_ACO, REPAY_CURRENT, INITIAL_DETER_RM_AMT,  TRACK, variable='Message'),
         
         THRESHOLD_EXCEEDED  = REQ_ACTION_THRESHOLD_fn(ACO_CATEGORY, RENEWING_ACO, REPAY_CURRENT, INITIAL_DETER_RM_AMT, TRACK,variable='Threshold'),
         
         REQ_SCENARIO = REQ_ACTION_THRESHOLD_fn(ACO_CATEGORY, RENEWING_ACO, REPAY_CURRENT, INITIAL_DETER_RM_AMT, TRACK, variable='Req_Scenario'),
         
         HI_LOW_RATIO = PROJ_TOT_REV/PROJ_TOT_EXP,
         
         ACO_HI_LOW_REV = hiLowFn(HI_LOW_RATIO))


#Examine output. This is just an interactive area to look
output %>% group_by(TRACK_1_PLUS_LOSS_LIMIT_CHANGE) %>% count()
output %>% group_by(ACO_CATEGORY) %>% count()
output %>% group_by(INITIAL_SCENARIO) %>% count()
output %>% group_by(ACO) %>% slice(1) %>% group_by(REQ_SCENARIO) %>% count()

#output %>% group_by(RENEWING_ACO, RENEWING_ACO_old) %>% count()

test = output %>% filter(TRACK == "1+")

#output %>% openxlsx::write.xlsx("Z:\\staff folders\\adraine\\Repayment Mechanism\\Step 6 Validation\\Step_9a.xlsx")

```


```{r Create Softrams output}

# Create functions to blank particular columns


#9b.	For certain variables created in Step (9a), only keep values for the Benchmark-based ACO-level record:      
        ##i.	If METHODOLOGY = “Revenue-based” or TIN <> “Total/Average”, set the following variables equal to missing:
          #1.	RISK
          #2.	REPAY_CURRENT
          #3	INITIAL_DETER_RM_AMT
          #4	TRACK_1+_LOSS_LIMIT_CHANGE
          #5.	THRESHOLD_EXCEEDED
          #6.	REQ_RM_AMT
          #7.	RM_ACTION
          #8.	HI_LOW_RATIO
          #9.	ACO_HI_LOW_REV
blankFn <- Vectorize(function(input, METHODOLOGY, TIN){
  if(METHODOLOGY == "Revenue-based" | TIN != "Total/Average"){
    return(NA)
  }else{return(input)}
})


# Blanking select columns for non-risk ACOs
      #10a.    If ACO_CATEGORY=”non_two_sided”  set the following variables equal to missing:
         ##i.	REPAY_CURRENT
         ##ii.	INITIAL_DETER_RM_AMT
         ##iii.	REQ_RM_AMT
blankRM <- Vectorize(function(RISK, input){
  if(RISK=="No"){return(NA)}
  else{return(input)}
})

# Blanking select columns for non-applicant, non July 1 starters, and non Track 1+ ACOs (Joe approved)
    #	For Track 1, 2, 3 ACOS, blank the following columns
      #10b.	If TRACK in (1,2,3), Blank
          ##i.	REPAY_CURRENT
          ##ii.	INITIAL_DETER_RM_AMT
          ##iii.	REQ_RM_AMT
blank_non_applicant <- Vectorize(function(TRACK, input){
  if(TRACK %in% c("1", "2", "3")){return(NA)}
  else{return(input)}
})





#9b, 10a, 10b
outputBlanked <- output %>%
  mutate(
    
    
         # Blanking select columns for non-risk ACOs
         REPAY_CURRENT = blankRM(RISK, REPAY_CURRENT),
         INITIAL_DETER_RM_AMT = blankRM(RISK, INITIAL_DETER_RM_AMT),
         REQ_RM_AMT = blankRM(RISK, REQ_RM_AMT),

         # Blanking risk-related columns for Revenue & TIN rows (has to be done bc only want to show this info once per ACO)
         RISK = blankFn(RISK, METHODOLOGY, TIN),
         REPAY_CURRENT = blankFn(REPAY_CURRENT, METHODOLOGY, TIN),
         INITIAL_DETER_RM_AMT = blankFn(INITIAL_DETER_RM_AMT, METHODOLOGY, TIN),
         TRACK_1_PLUS_LOSS_LIMIT_CHANGE = blankFn(TRACK_1_PLUS_LOSS_LIMIT_CHANGE, METHODOLOGY, TIN),
         THRESHOLD_EXCEEDED = blankFn(THRESHOLD_EXCEEDED, METHODOLOGY, TIN),
         REQ_RM_AMT = blankFn(REQ_RM_AMT, METHODOLOGY, TIN),
         RM_ACTION = blankFn(RM_ACTION, METHODOLOGY, TIN),
         HI_LOW_RATIO = blankFn(HI_LOW_RATIO, METHODOLOGY, TIN),
         ACO_HI_LOW_REV = blankFn(ACO_HI_LOW_REV, METHODOLOGY, TIN),
         
         # Blanking select columns for Track 1, 2, 3 ACOs
         REPAY_CURRENT = blank_non_applicant(TRACK, REPAY_CURRENT),
         INITIAL_DETER_RM_AMT = blank_non_applicant(TRACK, INITIAL_DETER_RM_AMT),
         REQ_RM_AMT = blank_non_applicant(TRACK, REQ_RM_AMT),



    )

#9c.	Sort the data as follows:
        #i.	First by ACO_ID
        #ii.	Second by METHODOLOGY (alphabetically, so “Benchmark-based” appears first)
        #iii.	For each ACO_ID/METHODOLOGY combination, the ACO-level record (TIN = “Total/Average”) should appear first, and then TIN-level records (TIN <> “Total/Average”) should be sorted by TIN. 

tinSortFn <- Vectorize(function(TIN){
  if(TIN == "Total/Average"){return(0)}else{return(as.numeric(TIN))}
})

outputBlankedSorted <- outputBlanked %>%
  mutate(overall = (TIN == "Total/Average"),
         tinSort = tinSortFn(TIN)) %>%
  arrange(ACO, METHODOLOGY, -overall, tinSort)


#9d.	Make the following additional manipulations to the data:
       ##i.	REQ_PCT: multiply by 100 so value is either 1 or 2.
       ##ii.	HI_LOW_RATIO: multiply by 100, then truncate to two decimal places (do not round in order to keep displayed value consistent with high/low revenue ACO determination)
       ##iii.	If ASSIGNED = 0, set ACO_HI_LOW_REV to missing.

#9e.	For all rows in dataset, set PROGRAM_YEAR = 2021
#9f.	Keep the only the variables listed in the table below. The variables should appear in the data set in this order (which is the order they will appear in the template), with the listed labels and formats applied (number in parentheses represents number of decimal places for rounding numeric variables):

outputFinal <- as_tibble(outputBlankedSorted) %>%
  
  mutate(ASSIGNED = as.numeric(round(ASSIGNED, 5)),
         ASSG_GROWTH = as.numeric(round(ASSG_GROWTH, 5)),
         PROJ_ASSIGNED = as.numeric(round(PROJ_ASSIGNED, 0)),
         DOLLAR_PER_BENE  = round(DOLLAR_PER_BENE, 2),
         DOLLAR_TREND = as.numeric(round(DOLLAR_TREND, 5)),
         PROJ_DOLLAR_PER_BENE = as.numeric(round(PROJ_DOLLAR_PER_BENE, 2)),
         PROJ_TOT_DOLLAR = as.numeric(round(PROJ_TOT_DOLLAR, 2)),
         REQ_PCT = as.numeric(round(REQ_PCT * 100, 2)),
         FCST_RM_AMT = as.numeric(round(FCST_RM_AMT, 0)), 
         REPAY_CURRENT = as.numeric(round(REPAY_CURRENT, 0)),
         INITIAL_DETER_RM_AMT = as.numeric(round(INITIAL_DETER_RM_AMT, 0)),
         REQ_RM_AMT = as.numeric(round(REQ_RM_AMT, 0)),
         HI_LOW_RATIO = as.numeric(floor(HI_LOW_RATIO * 10000) / 100),
         PROGRAM_YEAR = '2021') %>%
  
# name variables
  select("ACO ID" = ACO, 
         "Program Year" = PROGRAM_YEAR,
         "ACO Participant TIN" = TIN,
         "Benchmark- or Revenue-Based" = METHODOLOGY,
         Track = TRACK,
         "2019 Assigned Beneficiaries (A)" = ASSIGNED,
         "Assignment Growth (B)" = ASSG_GROWTH,
         "Projected 2021 Assigned Beneficiaries (C)" = PROJ_ASSIGNED,
         "2019 Dollars per Beneficiary (D)" = DOLLAR_PER_BENE,
         "Dollar Trend (E)" = DOLLAR_TREND,
         "Projected 2021 Dollars per Beneficiary (F)" = PROJ_DOLLAR_PER_BENE,
         "Projected 2021 Total Dollars (G)" = PROJ_TOT_DOLLAR,
         "Required Percentage (H)" = REQ_PCT, 
         "Forecast Repayment Mechanism Amount (I)" = FCST_RM_AMT,
         "Performance-Based Risk Track (J)" = RISK,
         "Existing Repayment Mechanism Amount (K)" = REPAY_CURRENT,
         "Initial Determined Repayment Mechanism Amount (L)" = INITIAL_DETER_RM_AMT,
         "Track 1+ Loss Limit Composition Changed (M)" = TRACK_1_PLUS_LOSS_LIMIT_CHANGE,
         "Met Threshold to Update Repayment Mechanism Amount (N)" = THRESHOLD_EXCEEDED,
         "Required Repayment Mechanism Amount (O)" = REQ_RM_AMT,
         "Repayment Mechanism Amount Action Required (P)" = RM_ACTION,
         "Revenue as Percent of Expenditures (Q)" = HI_LOW_RATIO,
         "High or Low Revenue ACO Determination (R)" = ACO_HI_LOW_REV
         )



#replace improper Hi Low revenue value
outputFinal$`Revenue as Percent of Expenditures (Q)`[outputFinal$`Revenue as Percent of Expenditures (Q)`==Inf] = NA

#don't need steps 10d or 9g because these are the data export steps


outputFinal %>% openxlsx::write.xlsx("Z:\\staff folders\\adraine\\Repayment Mechanism\\Step 6 Validation\\Step_10.xlsx")


```



```{r Create CMS file}


# Create functions to blank particular columns


#9b.	For certain variables created in Step (9a), only keep values for the Benchmark-based ACO-level record:      
        ##i.	If METHODOLOGY = “Revenue-based” or TIN <> “Total/Average”, set the following variables equal to missing:
          #1.	RISK
          #2.	REPAY_CURRENT
          #3	INITIAL_DETER_RM_AMT
          #4	TRACK_1+_LOSS_LIMIT_CHANGE
          #5.	THRESHOLD_EXCEEDED
          #6.	REQ_RM_AMT
          #7.	RM_ACTION
          #8.	HI_LOW_RATIO
          #9.	ACO_HI_LOW_REV
blankFn <- Vectorize(function(input, METHODOLOGY, TIN){
  if(METHODOLOGY == "Revenue-based" | TIN != "Total/Average"){
    return(NA)
  }else{return(input)}
})




#9b
outputBlanked_CMS <- output %>%
  mutate(
    
    


         # Blanking risk-related columns for Revenue & TIN rows (has to be done bc only want to show this info once per ACO)
         RISK = blankFn(RISK, METHODOLOGY, TIN),
         REPAY_CURRENT = blankFn(REPAY_CURRENT, METHODOLOGY, TIN),
         INITIAL_DETER_RM_AMT = blankFn(INITIAL_DETER_RM_AMT, METHODOLOGY, TIN),
         TRACK_1_PLUS_LOSS_LIMIT_CHANGE = blankFn(TRACK_1_PLUS_LOSS_LIMIT_CHANGE, METHODOLOGY, TIN),
         THRESHOLD_EXCEEDED = blankFn(THRESHOLD_EXCEEDED, METHODOLOGY, TIN),
         REQ_RM_AMT = blankFn(REQ_RM_AMT, METHODOLOGY, TIN),
         RM_ACTION = blankFn(RM_ACTION, METHODOLOGY, TIN),
         HI_LOW_RATIO = blankFn(HI_LOW_RATIO, METHODOLOGY, TIN),
         ACO_HI_LOW_REV = blankFn(ACO_HI_LOW_REV, METHODOLOGY, TIN)


    )

#9c.	Sort the data as follows:
        #i.	First by ACO_ID
        #ii.	Second by METHODOLOGY (alphabetically, so “Benchmark-based” appears first)
        #iii.	For each ACO_ID/METHODOLOGY combination, the ACO-level record (TIN = “Total/Average”) should appear first, and then TIN-level records (TIN <> “Total/Average”) should be sorted by TIN. 

tinSortFn <- Vectorize(function(TIN){
  if(TIN == "Total/Average"){return(0)}else{return(as.numeric(TIN))}
})

outputBlankedSorted_CMS <- outputBlanked_CMS %>%
  mutate(overall = (TIN == "Total/Average"),
         tinSort = tinSortFn(TIN)) %>%
  arrange(ACO, METHODOLOGY, -overall, tinSort)


#9d.	Make the following additional manipulations to the data:
       ##i.	REQ_PCT: multiply by 100 so value is either 1 or 2.
       ##ii.	HI_LOW_RATIO: multiply by 100, then truncate to two decimal places (do not round in order to keep displayed value consistent with high/low revenue ACO determination)
       ##iii.	If ASSIGNED = 0, set ACO_HI_LOW_REV to missing.

#9e.	For all rows in dataset, set PROGRAM_YEAR = 2021
#9f.	Keep the only the variables listed in the table below. The variables should appear in the data set in this order (which is the order they will appear in the template), with the listed labels and formats applied (number in parentheses represents number of decimal places for rounding numeric variables):

outputFinal_CMS <- as_tibble(outputBlankedSorted_CMS) %>%
  
  mutate(ASSIGNED = as.numeric(round(ASSIGNED, 5)),
         ASSG_GROWTH = as.numeric(round(ASSG_GROWTH, 5)),
         PROJ_ASSIGNED = as.numeric(round(PROJ_ASSIGNED, 0)),
         DOLLAR_PER_BENE  = round(DOLLAR_PER_BENE, 2),
         DOLLAR_TREND = as.numeric(round(DOLLAR_TREND, 5)),
         PROJ_DOLLAR_PER_BENE = as.numeric(round(PROJ_DOLLAR_PER_BENE, 2)),
         PROJ_TOT_DOLLAR = as.numeric(round(PROJ_TOT_DOLLAR, 2)),
         REQ_PCT = as.numeric(round(REQ_PCT * 100, 2)),
         FCST_RM_AMT = as.numeric(round(FCST_RM_AMT, 0)), 
         REPAY_CURRENT = as.numeric(round(REPAY_CURRENT, 0)),
         INITIAL_DETER_RM_AMT = as.numeric(round(INITIAL_DETER_RM_AMT, 0)),
         REQ_RM_AMT = as.numeric(round(REQ_RM_AMT, 0)),
         HI_LOW_RATIO = as.numeric(floor(HI_LOW_RATIO * 10000) / 100),
         PROGRAM_YEAR = '2021') %>%
  
# name variables
  select("ACO ID" = ACO, 
         "Program Year" = PROGRAM_YEAR,
         "ACO Participant TIN" = TIN,
         "Benchmark- or Revenue-Based" = METHODOLOGY,
         Track = TRACK,
         "2019 Assigned Beneficiaries (A)" = ASSIGNED,
         "Assignment Growth (B)" = ASSG_GROWTH,
         "Projected 2021 Assigned Beneficiaries (C)" = PROJ_ASSIGNED,
         "2019 Dollars per Beneficiary (D)" = DOLLAR_PER_BENE,
         "Dollar Trend (E)" = DOLLAR_TREND,
         "Projected 2021 Dollars per Beneficiary (F)" = PROJ_DOLLAR_PER_BENE,
         "Projected 2021 Total Dollars (G)" = PROJ_TOT_DOLLAR,
         "Required Percentage (H)" = REQ_PCT, 
         "Forecast Repayment Mechanism Amount (I)" = FCST_RM_AMT,
         "Performance-Based Risk Track (J)" = RISK,
         "Existing Repayment Mechanism Amount (K)" = REPAY_CURRENT,
         "Initial Determined Repayment Mechanism Amount (L)" = INITIAL_DETER_RM_AMT,
         "Track 1+ Loss Limit Composition Changed (M)" = TRACK_1_PLUS_LOSS_LIMIT_CHANGE,
         "Met Threshold to Update Repayment Mechanism Amount (N)" = THRESHOLD_EXCEEDED,
         "Required Repayment Mechanism Amount (O)" = REQ_RM_AMT,
         "Repayment Mechanism Amount Action Required (P)" = RM_ACTION,
         "Revenue as Percent of Expenditures (Q)" = HI_LOW_RATIO,
         "High or Low Revenue ACO Determination (R)" = ACO_HI_LOW_REV
         )



#replace improper Hi Low revenue value
outputFinal_CMS$`Revenue as Percent of Expenditures (Q)`[outputFinal$`Revenue as Percent of Expenditures (Q)`==Inf] = NA

#don't need step 9g because these are the data export steps


outputFinal_CMS %>% openxlsx::write.xlsx("Z:\\staff folders\\adraine\\Repayment Mechanism\\Step 6 Validation\\Step_9g.xlsx")


```


```{r Alex Compare}


Alex_data = read_excel("C:\\Users\\lhorvath\\Downloads\\Step10Excel_5.7.21.xls", sheet=1) 
names(Alex_data)
Alex_data$METHODOLOGY = tolower(Alex_data$METHODOLOGY)
outputFinal$`Benchmark- or Revenue-Based` = tolower(outputFinal_CMS$`Benchmark- or Revenue-Based`)
#merge together
check_data<-inner_join(outputFinal,Alex_data,by=c("ACO ID" = "ACO_ID","ACO Participant TIN" = "TIN", "Benchmark- or Revenue-Based"="METHODOLOGY"))
names(check_data)

#This should have zero rows. Datasets should have same ACO/TIN combinations
total_match<-anti_join(outputFinal,Alex_data,by=c("ACO ID" = "ACO_ID","ACO Participant TIN" = "TIN", "Benchmark- or Revenue-Based"="METHODOLOGY"))
nrow(total_match)

#replace missing and NA with a distinctive value for matching. This is to allow boolean comparisons in situations where data is missing
check_data[,]<-lapply(check_data[,],function(x) ifelse(x=="","-999999999",x))
check_data[,]<-lapply(check_data[,],function(x) ifelse(is.na(x) & is.character(x),"-999999999",x))
check_data[,]<-lapply(check_data[,],function(x) ifelse(is.na(x) & is.numeric(x),-999999999,x))


#make string to lower for comparison
check_data$action_y = gsub(" ", "", tolower(check_data$`Repayment Mechanism Amount Action Required (P)`))
check_data$action_x = gsub(" ", "", tolower(check_data$`RM_ACTION`))


library(quantmod)
names(check_data)

check_data<-check_data %>% 
  mutate(check_assigned=`2019 Assigned Beneficiaries (A)`==`ASSIGNED` ,
         
         check_assg_growth=round(`Assignment Growth (B)`,1)==round(`ASSG_GROWTH`,1),
         
         #had to adjust rounding here
         check_proj_2021_benes=if_else(`Projected 2021 Assigned Beneficiaries (C)` == 0, `Projected 2021 Assigned Beneficiaries (C)` == `PROJ_ASSG`, abs(Delt(`Projected 2021 Assigned Beneficiaries (C)`,round(`PROJ_ASSG`,0))) < .0001),
         
         check_Doll_per_bene=abs(Delt(as.numeric(`2019 Dollars per Beneficiary (D)`),as.numeric(`DOLLAR_PER_BENE`)))<.001,
         
         check_trend_dollar=round(as.numeric(`Dollar Trend (E)`),1)==round(as.numeric(`DOLLAR_TREND`),1),
         
         check_Proj_Doll_per_bene=abs(Delt(as.numeric(`Projected 2021 Dollars per Beneficiary (F)`),as.numeric(`PROJ_DOLLAR_PER_BENE`)))<.001,
         
         #had to adjust rounding here
         check_Proj_Total_Dollars= if_else(`Projected 2021 Total Dollars (G)` == 0, `Projected 2021 Total Dollars (G)` == `PROJ_TOT_DOLLAR`, abs(Delt(as.numeric(`Projected 2021 Total Dollars (G)`),as.numeric(round(`PROJ_TOT_DOLLAR`,2))))<.0001),
         
         check_req_perc=round(`Required Percentage (H)`,1)==round(`REQ_PCT`,1),
         
         #had to adjust rounding here
         check_forecast_repay=if_else(`Forecast Repayment Mechanism Amount (I)` == 0, `Forecast Repayment Mechanism Amount (I)` == round(`FCST_RM_AMT`,0),abs(Delt(`Forecast Repayment Mechanism Amount (I)`,round(`FCST_RM_AMT`,0)))<.001),
         
         check_risk_track=`Performance-Based Risk Track (J)`==`RISK`,
         
         check_existing_repay_amt=round(as.numeric(`Existing Repayment Mechanism Amount (K)`),0)==round(as.numeric(`REPAY_CURRENT`),0),
         
         check_Initial_Repay_amt=abs(Delt(as.numeric(`Initial Determined Repayment Mechanism Amount (L)`),as.numeric(`INITIAL_DETER_RM_AMT`)))<.0001,
         
         check_track_1plus_ll = `Track 1+ Loss Limit Composition Changed (M)` == `TRACK_1_PLUS_LOSS_LIMIT_CHANGE`,
         
         check_met_threshold = `Met Threshold to Update Repayment Mechanism Amount (N)` == `THRESHOLD_EXCEEDED`,
         
         check_required_repay_amt=abs(Delt(as.numeric(`Required Repayment Mechanism Amount (O)`),as.numeric(`REQ_RM_AMT`)))<.0001,
         
         check_action = `Repayment Mechanism Amount Action Required (P)` == `RM_ACTION`,
         
         check_action_lower = action_x == action_y,
         
         check_rev_perc_exp=`Revenue as Percent of Expenditures (Q)`- as.numeric(`HI_LOW_RATIO`)<=.001,
         
         check_hi_low_det=`High or Low Revenue ACO Determination (R)`==`ACO_HI_LOW_REV`)




# summarize comparisons
check_data %>% select(contains("check")) %>% 
  summarise_all(.funs=~(mean(.,na.rm=TRUE)))



check_action = check_data %>% filter(check_action_lower == FALSE)

test = Alex_data %>% filter(TRACK == "1", TIN == "Total/Average")
examine = outputFinal_CMS %>% filter(Track %in% c("2","3"))

```


```{r Keith Compare}

# This section allows comparison to Round 1 Final Data



Keith_data = read_excel("Z:\\pgm output\\ACO-3701 (Batch G2 High-Low Revenue and RM Calculations)\\Keith\\ACO3383_CMSxpt_Prod.xlsx", sheet=1) 

#merge together
check_data<-inner_join(outputFinal_CMS,Keith_data,by=c("ACO ID" = "ACOID","ACO Participant TIN" = 'TIN',"Benchmark- or Revenue-Based"="Benchmark- or Revenue-Based"))
names(check_data)

#This should have zero rows. Datasets should have same ACO/TIN combinations
total_match<-anti_join(outputFinal_CMS,Keith_data,by=c("ACO ID" = "ACOID","ACO Participant TIN" = 'TIN',"Benchmark- or Revenue-Based"="Benchmark- or Revenue-Based"))


#replace missing and NA with a distinctive value for matching. This is to allow boolean comparisons in situations where data is missing
check_data[,]<-lapply(check_data[,],function(x) ifelse(x=="","-999999999",x))
check_data[,]<-lapply(check_data[,],function(x) ifelse(is.na(x) & is.character(x),"-999999999",x))
check_data[,]<-lapply(check_data[,],function(x) ifelse(is.na(x) & is.numeric(x),-999999999,x))


#make string to lower for comparison
check_data$action_y = gsub(" ", "", tolower(check_data$`Repayment Mechanism Action Required (P)`))
check_data$action_x = gsub(" ", "", tolower(check_data$`Repayment Mechanism Amount Action Required (P)`))


library(quantmod)
names(check_data)

check_data<-check_data %>% 
  mutate(check_assigned=`2019 Assigned Beneficiaries (A)`==`2018 Assigned Beneficiaries (A)` ,
         
         check_assg_growth=round(`Assignment Growth (B).x`,1)==round(`Assignment Growth (B).y`,1),
         
         check_proj_2021_benes=if_else(`Projected 2021 Assigned Beneficiaries (C).x` == 0, `Projected 2021 Assigned Beneficiaries (C).x` == `Projected 2021 Assigned Beneficiaries (C).y`, abs(Delt(`Projected 2021 Assigned Beneficiaries (C).x`,`Projected 2021 Assigned Beneficiaries (C).y`)) < .0001),
         
         check_Doll_per_bene=Delt(as.numeric(`2019 Dollars per Beneficiary (D).x`),as.numeric(`2019 Dollars per Beneficiary (D).y`))<.0001,
         
         check_trend_dollar=round(as.numeric(`Dollar Trend (E).x`),1)==round(as.numeric(`Dollar Trend (E).y`),1),
         
         check_Proj_Doll_per_bene=abs(Delt(as.numeric(`Projected 2021 Dollars per Beneficiary (F).x`),as.numeric(`Projected 2021 Dollars per Beneficiary (F).y`)))<.001,
         
         check_Proj_Total_Dollars= if_else(`Projected 2021 Total Dollars (G).x` == 0, `Projected 2021 Total Dollars (G).x` == `Projected 2021 Total Dollars (G).y`, abs(Delt(as.numeric(`Projected 2021 Total Dollars (G).x`),as.numeric(`Projected 2021 Total Dollars (G).y`)))<.0001),
         
         check_req_perc=round(`Required Percentage (H).x`,1)==round(`Required Percentage (H).y`,1),
         
         check_forecast_repay=if_else(`Forecast Repayment Mechanism Amount (I).x` == 0, `Forecast Repayment Mechanism Amount (I).x` == `Forecast Repayment Mechanism Amount (I).y`,abs(Delt(`Forecast Repayment Mechanism Amount (I).x`,`Forecast Repayment Mechanism Amount (I).y`))<.001),
         
         check_risk_track=`Performance-Based Risk Track (J).x`==`Performance-Based Risk Track (J).y`,
         
         check_existing_repay_amt=round(as.numeric(`Existing Repayment Mechanism Amount (K).x`),0)==round(as.numeric(`Existing Repayment Mechanism Amount (K).y`),0),
         
         check_Initial_Repay_amt=abs(Delt(as.numeric(`Initial Determined Repayment Mechanism Amount (L).x`),as.numeric(`Initial Determined Repayment Mechanism Amount (L).y`)))<.0001,
         
         check_track_1plus_ll = `Track 1+ Loss Limit Composition Changed (M).x` == `Track 1+ Loss Limit Composition Changed (M).y`,
         
         check_met_threshold = `Met Threshold to Update Repayment Mechanism Amount (N)` == `Threshold for Repayment Mechanism Amount Increase Exceeded (N)`,
         
         check_required_repay_amt=abs(Delt(as.numeric(`Required Repayment Mechanism Amount (O).x`),as.numeric(`Required Repayment Mechanism Amount (O).y`)))<.0001,
         
         check_action = `Repayment Mechanism Amount Action Required (P)` == `Repayment Mechanism Action Required (P)`,
         
         check_action_lower = action_x == action_y,
         
         check_rev_perc_exp=abs(Delt(as.numeric(`Revenue as Percent of Expenditures (Q).x`),as.numeric(`Revenue as Percent of Expenditures (Q).y`)))<.0001,
         
         check_hi_low_det=`High or Low Revenue ACO Determination (R)`==`High or Low Revenue ACO_ID Determination (R)`)




# summarize comparisons
check_data %>% select(contains("check")) %>% 
  summarise_all(.funs=~(mean(.,na.rm=TRUE)))




investigate = check_data %>% filter(check_action_lower == FALSE)
outpinvestigate = output %>% filter(ACO == "A3852")

investigate$`Existing Repayment Mechanism Amount (K).x`
investigate$`Existing Repayment Mechanism Amount (K).y`

#doll_per_bene check
TIN_filtered = qaTinRevenue %>% filter(TIN=='010660458') %>% mutate(doll_per_bene = TIN_TOT_REV/240)
CCN_filtered = qaCcnRevenue %>% left_join(qaAcoTinCcn) %>% filter(TIN=='010660458')


test = output %>% filter(ACO=='A3852')


```




```{r Kevin Compare}

# This section allows comparison to Round 1 Final Data.

# NEED TO UPDATE



Kevin_data = read_excel("Z:\\pgm output\\ACO-3701 (Batch G2 High-Low Revenue and RM Calculations)\\Kevin\\TI00.MSSP.D4MZ.P7B17E1J.DS10.xlsx", sheet=1)%>% 
  mutate(`ACO Participant TIN` = str_pad(`ACO Participant TIN`, 9, side = c("left"), pad = "0"))



#merge together
check_data<-inner_join(outputFinal_CMS,Kevin_data,by=c("ACO ID" = "ACO ID","ACO Participant TIN" = 'ACO Participant TIN',"Benchmark- or Revenue-Based"))
names(check_data)

#This should have zero rows. Datasets should have same ACO/TIN combinations
total_match<-anti_join(outputFinal_CMS,Kevin_data,by=c("ACO ID" = "ACO ID","ACO Participant TIN" = 'ACO Participant TIN',"Benchmark- or Revenue-Based"))


#replace missing and NA with a distinctive value for matching. This is to allow boolean comparisons in situations where data is missing
check_data[,]<-lapply(check_data[,],function(x) ifelse(x=="","-999999999",x))
check_data[,]<-lapply(check_data[,],function(x) ifelse(is.na(x) & is.character(x),"-999999999",x))
check_data[,]<-lapply(check_data[,],function(x) ifelse(is.na(x) & is.numeric(x),-999999999,x))


#make string to lower for comparison
check_data$action_x = gsub(" ", "", tolower(check_data$`Repayment Mechanism Amount Action Required (P)`))
check_data$action_y = gsub(" ", "", tolower(check_data$`Repayment Mechanism Amount Action Required`))


library(quantmod)
names(check_data)

check_data<-check_data %>%
  mutate(check_assigned=`2019 Assigned Beneficiaries (A)`==`2019 Assigned Beneficiaries` ,
         
         check_assg_growth=round(`Assignment Growth (B)`,1)==round(`Assignment Growth (B)`,1),
         
         check_proj_2021_benes=if_else(`Projected 2021 Assigned Beneficiaries (C)` == 0, `Projected 2021 Assigned Beneficiaries (C)` == `Projected 2021 Assigned Beneficiaries`, abs(Delt(`Projected 2021 Assigned Beneficiaries (C)`,`Projected 2021 Assigned Beneficiaries`)) < .0001),
         
         check_Doll_per_bene=Delt(as.numeric(`2019 Dollars per Beneficiary (D)`),as.numeric(`2019 Dollars per Beneficiary`))<.0001,
         
         check_trend_dollar=round(as.numeric(`Dollar Trend (E)`),1)==round(as.numeric(`Dollar Trend`),1),
         
         check_Proj_Doll_per_bene=abs(Delt(as.numeric(`Projected 2021 Dollars per Beneficiary (F)`),as.numeric(`Projected 2021 Dollars per Beneficiary`)))<.0001,
         
         check_Proj_Total_Dollars= if_else(`Projected 2021 Total Dollars (G)` == 0, `Projected 2021 Total Dollars (G)` == `Projected 2021 Total Dollars`, abs(Delt(as.numeric(`Projected 2021 Total Dollars (G)`),as.numeric(`Projected 2021 Total Dollars`)))<.0001),
         
         check_req_perc=round(`Required Percentage (H)`,1)==round(`Required Percentage`,1),
         
         check_forecast_repay=if_else(`Forecast Repayment Mechanism Amount (I)` == 0, `Forecast Repayment Mechanism Amount (I)` == `Forecast Repayment Mechanism Amount`,abs(Delt(`Forecast Repayment Mechanism Amount (I)`,`Forecast Repayment Mechanism Amount`))<.0001),
         
         check_risk_track=`Performance-Based Risk Track (J)`==`Performance-Based Risk Track`,
         
         check_existing_repay_amt=round(as.numeric(`Existing Repayment Mechanism Amount (K)`),1)==round(as.numeric(`Existing Repayment Mechanism Amount`),1),
         
         check_Initial_Repay_amt=abs(Delt(as.numeric(`Initial Determined Repayment Mechanism Amount (L)`),as.numeric(`Initial Determined Repayment Mechanism Amount`)))<.0001,
         
         check_track_1plus_ll = `Track 1+ Loss Limit Composition Changed (M)` == `Track 1+ Loss Limit Composition Changed`,
         
         check_met_threshold = `Met Threshold to Update Repayment Mechanism Amount (N)` == `Met Threshold to Update Repayment Mechanism Amount`,
         
         check_required_repay_amt=abs(Delt(as.numeric(`Required Repayment Mechanism Amount (O)`),as.numeric(`Required Repayment Mechanism Amount`)))<.0001,
         
         check_action = `Repayment Mechanism Amount Action Required (P)` == `Repayment Mechanism Amount Action Required`,
         
         check_action_lower = action_x == action_y,
         
         check_rev_perc_exp=abs(Delt(as.numeric(`Revenue as Percent of Expenditures (Q)`),as.numeric(`Revenue as Percent of Expenditures`)))<.0001,
         
         check_hi_low_det=`High or Low Revenue ACO Determination (R)`==`High or Low Revenue ACO Determination`)



# summarize comparisons
check_data %>% select(contains("check")) %>% 
  summarise_all(.funs=~(mean(.,na.rm=TRUE)))


investigate = check_data %>% filter(check_action_lower == FALSE)
```


```{r Check Kevin's SAS file}

# NEED TO UPDATE

library(haven)


Kevin_SAS = read_sas("Z:\\pgm output\\ACO-3701 (Batch G2 High-Low Revenue and RM Calculations)\\Kevin\\analytic_ds_10s.sas7bdat")
Kevin_SAS$ACO_CATEGORY = NULL


makeVlist <- function(dta) { 
     labels <- sapply(dta, function(x) attr(x, "label"))
      return(unlist(labels))
}

variable_names = makeVlist(Kevin_SAS)


Kevin_SAS = Kevin_SAS %>% 
   mutate(ASSIGNED = as.numeric(round(ASSIGNED, 5)),
         ASSG_GROWTH = as.numeric(round(ASSG_GROWTH, 5)),
         PROJ_ASSIGNED = as.numeric(round(PROJ_ASSIGNED, 0)),
         DOLLAR_PER_BENE  = round(DOLLAR_PER_BENE, 2),
         DOLLAR_TREND = as.numeric(round(DOLLAR_TREND, 5)),
         PROJ_DOLLAR_PER_BENE = as.numeric(round(PROJ_DOLLAR_PER_BENE, 2)),
         PROJ_TOT_DOLLAR = as.numeric(round(PROJ_TOT_DOLLAR, 2)),
         REQ_PCT = as.numeric(round(REQ_PCT, 2)),
         FCST_RM_AMT = as.numeric(round(FCST_RM_AMT, 0)), 
         REPAY_CURRENT = as.numeric(round(REPAY_CURRENT, 0)),
         INITIAL_DETER_RM_AMT = as.numeric(round(INITIAL_DETER_RM_AMT, 0)),
         REQ_RM_AMT = as.numeric(round(REQ_RM_AMT, 0))) 
  
names(Kevin_SAS) = variable_names

Kevin_SAS %>% mutate_if(is.factor, as.character) -> Kevin_SAS





#merge together
check_data<-inner_join(outputFinal,Kevin_SAS,by=c("ACO ID" = "ACO ID","ACO Participant TIN" = 'ACO Participant TIN',"Benchmark- or Revenue-Based"))
names(check_data)

#This should have zero rows. Datasets should have same ACO/TIN combinations
total_match<-anti_join(outputFinal,Kevin_SAS,by=c("ACO ID" = "ACO ID","ACO Participant TIN" = 'ACO Participant TIN',"Benchmark- or Revenue-Based"))


#replace missing and NA with a distinctive value for matching. This is to allow boolean comparisons in situations where data is missing
check_data[,]<-lapply(check_data[,],function(x) ifelse(x=="","-999999999",x))
check_data[,]<-lapply(check_data[,],function(x) ifelse(is.na(x) & is.character(x),"-999999999",x))
check_data[,]<-lapply(check_data[,],function(x) ifelse(is.na(x) & is.numeric(x),-999999999,x))



#make string to lower for comparison
check_data$action_x = gsub(" ", "", tolower(check_data$`Repayment Mechanism Amount Action Required (P)`))
check_data$action_y = gsub(" ", "", tolower(check_data$`Repayment Mechanism Amount Action Required`))


library(quantmod)


check_data<-check_data %>% 
  mutate(check_assigned=`2019 Assigned Beneficiaries (A)`==`2019 Assigned Beneficiaries` ,
         
         check_assg_growth=round(`Assignment Growth (B)`,1)==round(`Assignment Growth (B)`,1),
         
         check_proj_2021_benes=if_else(`Projected 2021 Assigned Beneficiaries (C)` == 0, `Projected 2021 Assigned Beneficiaries (C)` == `Projected 2021 Assigned Beneficiaries`, abs(Delt(`Projected 2021 Assigned Beneficiaries (C)`,`Projected 2021 Assigned Beneficiaries`)) < .0001),
         
         check_Doll_per_bene=Delt(as.numeric(`2019 Dollars per Beneficiary (D)`),as.numeric(`2019 Dollars per Beneficiary`))<.0001,
         
         check_trend_dollar=round(as.numeric(`Dollar Trend (E)`),1)==round(as.numeric(`Dollar Trend`),1),
         
         check_Proj_Doll_per_bene=abs(Delt(as.numeric(`Projected 2021 Dollars per Beneficiary (F)`),as.numeric(`Projected 2021 Dollars per Beneficiary`)))<.0001,
         
         check_Proj_Total_Dollars= if_else(`Projected 2021 Total Dollars (G)` == 0, `Projected 2021 Total Dollars (G)` == `Projected 2021 Total Dollars`, abs(Delt(as.numeric(`Projected 2021 Total Dollars (G)`),as.numeric(`Projected 2021 Total Dollars`)))<.0001),
         
         check_req_perc=round(`Required Percentage (H)`,1)==round(`Required Percentage`,1),
         
         check_forecast_repay=if_else(`Forecast Repayment Mechanism Amount (I)` == 0, `Forecast Repayment Mechanism Amount (I)` == `Forecast Repayment Mechanism Amount`,abs(Delt(`Forecast Repayment Mechanism Amount (I)`,`Forecast Repayment Mechanism Amount`))<.0001),
         
         check_risk_track=`Performance-Based Risk Track (J)`==`Performance-Based Risk Track`,
         
         check_existing_repay_amt=round(as.numeric(`Existing Repayment Mechanism Amount (K)`),1)==round(as.numeric(`Existing Repayment Mechanism Amount`),1),
         
         check_Initial_Repay_amt=abs(Delt(as.numeric(`Initial Determined Repayment Mechanism Amount (L)`),as.numeric(`Initial Determined Repayment Mechanism Amount`)))<.0001,
         
         check_track_1plus_ll = `Track 1+ Loss Limit Composition Changed (M)` == `Track 1+ Loss Limit Composition Changed`,
         
         check_met_threshold = `Met Threshold to Update Repayment Mechanism Amount (N)` == `Met Threshold to Update Repayment Mechanism Amount`,
         
         check_required_repay_amt=abs(Delt(as.numeric(`Required Repayment Mechanism Amount (O)`),as.numeric(`Required Repayment Mechanism Amount`)))<.0001,
         
         check_action = `Repayment Mechanism Amount Action Required (P)` == `Repayment Mechanism Amount Action Required`,
         
         check_action_lower = action_x == action_y,
         
         check_rev_perc_exp=abs(Delt(as.numeric(`Revenue as Percent of Expenditures (Q)`),as.numeric(`Revenue as Percent of Expenditures`)))<.0001,
         
         check_hi_low_det=`High or Low Revenue ACO Determination (R)`==`High or Low Revenue ACO Determination`)



# summarize comparisons
check_data %>% select(contains("check")) %>% 
  summarise_all(.funs=~(mean(.,na.rm=TRUE)))


investigate = check_data %>% filter(check_action_lower == FALSE)


```

```{r Check Final POR}

POR = read_excel("Z:\\participant management\\prescreening\\2021 Prescreening\\Batch G2\\Participation Options Report\\Participation_Options_PY2021_RFI-2_20200911.xlsx", sheet=3)%>% 
  mutate(`ACO Participant TIN` = str_pad(`ACO Participant TIN`, 9, side = c("left"), pad = "0"))



#merge together
check_data<-inner_join(outputFinal,POR,by=c("ACO ID" = "ACO ID","ACO Participant TIN" = 'ACO Participant TIN',"Benchmark- or Revenue-Based"))
names(check_data)

#This should have zero rows. Datasets should have same ACO/TIN combinations
total_match<-anti_join(outputFinal,POR,by=c("ACO ID" = "ACO ID","ACO Participant TIN" = 'ACO Participant TIN',"Benchmark- or Revenue-Based"))


#replace missing and NA with a distinctive value for matching. This is to allow boolean comparisons in situations where data is missing
check_data[,]<-lapply(check_data[,],function(x) ifelse(x=="","-999999999",x))
check_data[,]<-lapply(check_data[,],function(x) ifelse(is.na(x) & is.character(x),"-999999999",x))
check_data[,]<-lapply(check_data[,],function(x) ifelse(is.na(x) & is.numeric(x),-999999999,x))


#make string to lower for comparison
check_data$action_x = gsub(" ", "", tolower(check_data$`Repayment Mechanism Amount Action Required (P)`))
check_data$action_y = gsub(" ", "", tolower(check_data$`Repayment Mechanism Amount Action Required`))


library(quantmod)
names(check_data)

check_data<-check_data %>%
  mutate(check_assigned=`2019 Assigned Beneficiaries (A)`==`2019 Assigned Beneficiaries` ,
         
         check_assg_growth=round(`Assignment Growth (B)`,1)==round(`Assignment Growth (B)`,1),
         
         check_proj_2021_benes=if_else(`Projected 2021 Assigned Beneficiaries (C)` == 0, `Projected 2021 Assigned Beneficiaries (C)` == `Projected 2021 Assigned Beneficiaries`, abs(Delt(`Projected 2021 Assigned Beneficiaries (C)`,`Projected 2021 Assigned Beneficiaries`)) < .0001),
         
         check_Doll_per_bene=Delt(as.numeric(`2019 Dollars per Beneficiary (D)`),as.numeric(`2019 Dollars per Beneficiary`))<.0001,
         
         check_trend_dollar=round(as.numeric(`Dollar Trend (E)`),1)==round(as.numeric(`Dollar Trend`),1),
         
         check_Proj_Doll_per_bene=abs(Delt(as.numeric(`Projected 2021 Dollars per Beneficiary (F)`),as.numeric(`Projected 2021 Dollars per Beneficiary`)))<.0001,
         
         check_Proj_Total_Dollars= if_else(`Projected 2021 Total Dollars (G)` == 0, `Projected 2021 Total Dollars (G)` == `Projected 2021 Total Dollars`, abs(Delt(as.numeric(`Projected 2021 Total Dollars (G)`),as.numeric(`Projected 2021 Total Dollars`)))<.0001),
         
         check_req_perc=round(`Required Percentage (H)`,1)==round(`Required Percentage`,1),
         
         check_forecast_repay=if_else(`Forecast Repayment Mechanism Amount (I)` == 0, `Forecast Repayment Mechanism Amount (I)` == `Forecast Repayment Mechanism Amount`,abs(Delt(`Forecast Repayment Mechanism Amount (I)`,`Forecast Repayment Mechanism Amount`))<.0001),
         
         check_risk_track=`Performance-Based Risk Track (J)`==`Performance-Based Risk Track`,
         
         check_existing_repay_amt=round(as.numeric(`Existing Repayment Mechanism Amount (K)`),1)==round(as.numeric(`Existing Repayment Mechanism Amount`),1),
         
         check_Initial_Repay_amt=abs(Delt(as.numeric(`Initial Determined Repayment Mechanism Amount (L)`),as.numeric(`Initial Determined Repayment Mechanism Amount`)))<.0001,
         
         check_track_1plus_ll = `Track 1+ Loss Limit Composition Changed (M)` == `Track 1+ Loss Limit Composition Changed`,
         
         check_met_threshold = `Met Threshold to Update Repayment Mechanism Amount (N)` == `Met Threshold to Update Repayment Mechanism Amount`,
         
         check_required_repay_amt=abs(Delt(as.numeric(`Required Repayment Mechanism Amount (O)`),as.numeric(`Required Repayment Mechanism Amount`)))<.0001,
         
         check_action = `Repayment Mechanism Amount Action Required (P)` == `Repayment Mechanism Amount Action Required`,
         
         check_action_lower = action_x == action_y,
         
         check_rev_perc_exp=abs(Delt(as.numeric(`Revenue as Percent of Expenditures (Q)`),as.numeric(`Revenue as Percent of Expenditures`)))<.0001,
         
         check_hi_low_det=`High or Low Revenue ACO Determination (R)`==`High or Low Revenue ACO Determination`)



# summarize comparisons
check_data %>% select(contains("check")) %>% 
  summarise_all(.funs=~(mean(.,na.rm=TRUE)))


investigate = check_data %>% filter(check_action_lower == FALSE)

```


