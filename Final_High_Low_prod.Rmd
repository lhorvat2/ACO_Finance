---
title: "Prescreen_revenue_production_check"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

6
#11/17/2020
rm(list = ls())
library(dplyr)
library(readxl)
library(tidyr)
library(stringr)
library(readr)
library(lubridate)
library(reticulate)
```






```{r Set up tracks, read in current repayment amounts}

TRACK <- c("1", "2", "3", "1+", "A", "B", "C", "D", "E", "EN")
RISK <- c("No", "Yes", "Yes", "Yes", "No", "No", "Yes", "Yes", "Yes", "Yes")

trackRisk <- as_tibble(cbind(TRACK, RISK))

#actual repayment. will not change in any round
repay <- read_excel("Z:\\finance\\participant revenue and expenditures\\2021 Cycle\\Inputs\\Final_High_Low\\Repayment Mechanism Tracker_consolidated_Bland_Update.xlsx") %>%
  select(ACO = 1, REPAY_CURRENT) %>% group_by(ACO) %>% slice(1)

```




```{r Read in TIN/CCN expenditure and revenue files}

#actual expends/revenue. will not change in any round until final
ACO_expends = read_csv("Z:\\pgm\\ibugarinovic\\programs\\MSSP\\G4 batch\\Repayment Mechanism\\B5A19G4R.ACO19.CSV") %>% rename(ACO = ACOID)



qaTinRevenue <- as_tibble(read_csv("Z:\\pgm output\\ACO-2648 TIN and CCN Revenues\\TI00.MSSP.D4MZ.P7A19E0.PROF1.CSV")) %>%
  mutate(TIN = as.character(TIN),
         TIN = str_pad(TIN, 9, side = c("left"), pad = "0"))


qaCcnRevenue <- as_tibble(read_csv("Z:\\pgm output\\ACO-2648 TIN and CCN Revenues\\TI00.MSSP.D4MZ.P7A19E0.INST2.CSV")) %>%
  mutate(CCN = as.character(CCN),
         CCN = str_pad(CCN, 6, side = c("left"), pad = "0"))

```





```{r Read in crosswalk files}

qaAcoTin = as_tibble(haven::read_sas("Y:\\data\\jsciandra\\Prescreening\\2021\\G4\\batch_g4_tin_20201028.sas7bdat")) %>%
  select(ACO = ACO_ID, TIN, PROGRAM_YEAR = Program_Year, TRACK = ACO_Track, Latest_Agreement_Start_Date = Latest_Agreement_Start_Date, Renewal_Effective_Date = Renewal_Effective_Date, ACO_START_DATE = ACO_Start_Date, INTO_RISK = Into_Risk) %>%
  #doing this to drop all leading zeroes up front so everything merges nicely
  mutate(TIN = as.character(TIN),
         TIN = str_pad(TIN, 9, side = c("left"), pad = "0")) 

qaAcoTin %>% group_by(TRACK) %>% count()


#some validations
sum(is.na(qaAcoTin$Latest_Agreement_Start_Date))
sum(is.na(qaAcoTin$Renewal_Effective_Date))
sum(is.na(qaAcoTin$ACO_Current_Start_Date))





# Comparisons are much faster with Latest Agreement Start Date as a character
#will have to be edited if not using SAS input from Keith
qaAcoTin$Latest_Agreement_Start_Date = as.character(qaAcoTin$Latest_Agreement_Start_Date)
qaAcoTin$ACO_START_DATE = as.character(qaAcoTin$ACO_START_DATE)

unique(qaAcoTin$Latest_Agreement_Start_Date)
unique(qaAcoTin$ACO_START_DATE)


acoData <- qaAcoTin %>% distinct(ACO, .keep_all = TRUE) %>% select(-TIN)


#ACO/TIN/CCN crosswalk
qaAcoTinCcn <- as_tibble(haven::read_sas("Y:\\data\\jsciandra\\Prescreening\\2021\\G4\\batch_g4_ccn_20201028.sas7bdat")) %>%
  filter(Use_Record == 1) %>%
  select(ACO = ACO_ID, TIN, CCN) %>%
  mutate(ACO = as.character(ACO),
         TIN = as.character(TIN),
         CCN = as.character(CCN),
         TIN = str_pad(TIN, 9, side = c("left"), pad = "0"),
         CCN = str_pad(CCN, 6, side = c("left"), pad = "0")) %>% 
  #this is exerimental 
  distinct(ACO, TIN, CCN)

qaAcoTinCcn$CCN_digits = nchar(qaAcoTinCcn$CCN)
qaAcoTinCcn$TIN = gsub("'","", qaAcoTinCcn$TIN)



```







```{r Read in new inputs for 2020}

# Track 1+ Current Composition Status
Track_1_plus_status = read_csv("Z:\\finance\\participant revenue and expenditures\\2021 Cycle\\Inputs\\Final_High_Low\\Track_1_plus_status_final.csv")


Track_1_plus_change = read_csv("Z:\\finance\\participant revenue and expenditures\\2021 Cycle\\Inputs\\Final_High_Low\\Track_1_plus_change_final.csv")
```



```{r 1 }
#1.	Create an ACO/TIN/CCN-level file with revenues.
  #a.	Merge the CCN-level revenue file onto the ACO/TIN/CCN crosswalk.
    #i.	If a CCN is in the CCN-level revenue file, but not the ACO/TIN/CCN crosswalk, drop the record.
    #ii.	If a CCN is in the ACO/TIN/CCN crosswalk but not the CCN-level revenue file, keep the record and set CCN_TOT_REV equal to 0.
    #iii.	Rename CCN_TOT_REV as TOT_REV
    #iv.	The resulting data set should have 1 record for each ACO/TIN/CCN combination in the original ACO/TIN/CCN crosswalk.
    #v.	Keep only variables CCN, TOT_REV



# i.
qaCcn <- qaAcoTinCcn %>% 
  left_join(qaCcnRevenue,by= "CCN") %>% 
  # ii
  replace_na(list(CCN_TOT_REV = 0)) %>%
  # iii, iv, v. 
  select(ACO, CCN, TOT_REV = CCN_TOT_REV)




```



```{r 2}
#2.	Create a new ACO-level file using the ACO/TIN/CCN-level data set created in Step (1).
  #a.	Starting with the data set created in Step (1):
    #i.	Drop any records with duplicative ACO/CCN combinations.
      #1.	For example, if there are two records where ACO_ID = A1111 and CCN = 111111, drop one of these records.
      #2.	The purpose of this step is to ensure that if a CCN is linked to multiple TINs within the same ACO, the CCN’s revenue will only be counted once when calculating ACO-level values.
  #b.	Using the modified data set from Step (2a), create a new data set by calculating the following for each ACO_ID:
    #i.	TOT_REV = ∑ TOT_REV
    #ii.	NUM_CCN = number of CCNs per ACO
    #iii.	The resulting data set should have 1 record for each ACO in the original ACO/TIN/CCN crosswalk.


qaACO_from_Ccn <- qaCcn %>% 
  #a.i
  group_by(ACO,CCN) %>% slice(1) %>% 
  group_by(ACO) %>% 
  #b
  summarise(
    TOT_REV = sum(TOT_REV),
    NUM_CCN = n())
  
  




```


```{r 3}
#3.	Create an ACO/TIN level file with revenues.
  #a.	Merge the TIN-level revenue file onto the ACO/TIN crosswalk.
    #i.	If a TIN is in the TIN-level revenue file but not the ACO/TIN crosswalk, drop the record.
    #ii.	If a TIN is in the ACO/TIN-level data set from Step (3b) but not the TIN-level revenue file , keep the record and set TIN_TOT_REV equal to 0.
    #iii.	Rename TIN_TOT_REV as TOT_REV
    #iv.	The resulting data set should have 1 record for each ACO/TIN combination in the original ACO/TIN crosswalk.
    #v.	Generate a variable called NUM_TIN which is the number of TINs per ACO


# i.
qaTin <- qaAcoTin %>% 
  left_join(qaTinRevenue,by= "TIN") %>% 
  # ii
  replace_na(list(TIN_TOT_REV = 0)) %>%
  # iii, iv
  select(ACO, TIN, TOT_REV = TIN_TOT_REV) %>% 
  # v
  group_by(ACO) %>% 
  mutate(NUM_TIN = n())




```


```{r 4}
#4.	Create a new ACO-level data set that incorporates both CCN-level and TIN-level revenues.
  #a.	Stack the data sets created in Step (2) and Step (3).
  #b.	Using the stacked data set, create a new data set by calculating the following for each ACO_ID:
    #i.	TOT_REV = ∑ TOT_REV
    #ii.	NUM_CCN = Max(NUM_CCN) per ACO (or use alternative methodology to calculate the number of CCNs per ACO. Used Max in my code because we stacked the TIN and CCN level records so rows from #TIN records had 0 while all rows from CCN records were constant)
      #1.	Ensure this is set to 0 if ACO has no CCNs
    #iii.	NUM_TIN = Max(NUM_TIN) per ACO (or use alternative methodology to calculate the number of TINs per ACO. Used Max in my code because we stacked the TIN and CCN level records so rows from #CCN records had 0 while all rows from TIN records were constant)
    #iv.	The resulting data set should have 1 record for each ACO in the original ACO/TIN crosswalk.
    #v.	Ensure that variable INTO_RISK from the ACO_TIN crosswalk is rolled up to the ACO level. This variable is formatted such that it is constant across an ACO. 


#a
qaAco <- bind_rows(qaTin, qaACO_from_Ccn) %>%
  group_by(ACO) %>% 
#b
  summarise(
    TOT_REV = sum(TOT_REV, na.rm=TRUE),
    NUM_CCN = max(NUM_CCN,na.rm=TRUE),
    NUM_TIN = max(NUM_TIN, na.rm=TRUE),
      ) %>% 
    replace_na(list(NUM_CCN = 0, NUM_TIN = 0))


qaAco$NUM_CCN[qaAco$NUM_CCN == -Inf] = 0



```


```{r 5 }
#5.	Calculate ACO-level total expenditures.
  #a.	Using the ACO-level expenditures data set, calculate the following:
    #i.	Calculate TOT_EXP as ∑ ([status]_EXP_PER_BENE * [status]_PY)
      #1.	Note that for some records one or more of the [status]_EXP_PER_BENE or [status]_PY variables may be missing. Ensure that TOT_EXP is not being set to missing in these cases.
    #ii.	Keep only the following variables: ACO_ID, TOT_AB, TOT_EXP
  #b.	The resulting data set should have 1 record for each ACO in the original ACO-level expenditure file. In the final round, this should be the same set of ACOs in the ACO/TIN crosswalk. Please check if this is the case and provide notification if it is not and identify mismatches.

ACO_Expends_sum = ACO_expends %>%
  #ai
  replace_na(list(ESRD_EXP_PER_BENE = 0, DIS_EXP_PER_BENE = 0, AGDU_EXP_PER_BENE = 0, AGND_EXP_PER_BENE = 0)) %>%
  #a,b.
  mutate(TOT_EXP = (ESRD_EXP_PER_BENE * ESRD_PY) + (DIS_EXP_PER_BENE * DIS_PY) + (AGDU_EXP_PER_BENE * AGDU_PY) + (AGND_EXP_PER_BENE * AGND_PY)) 



```


```{r 6 }
#6.	Combine the ACO-level revenue and expenditures data sets. Create a new data set:
  #a.	Starting with the ACO-level revenue data set created in step (4), merge into this data set with the ACO-level expenditures data created in step (5). Merge by ACO_ID. This should be a left join
  #b.	Keep the following variables
    #i.	ACO_ID
    #ii.	TOT_REV
    #iii.	TOT_AB
    #iv.	TOT_EXP
    #v.	NUM_CCN
    #vi.	NUM_TIN 
    #vii.	The resulting data set should have 1 record for each ACO in the original ACO/TIN crosswalk. (please check and note any discrepancies in jira)
    #viii.	Please create an intermediate dataset and save and output as an Excel File as a record of TOT_AB, TOT_EXP, TOT_REV, NUM_CCN, and NUM_TIN per ACO

#a
ACO_benchmark = left_join(ACO_Expends_sum, qaAco,by="ACO") %>% 
  #b
  select(ACO, 
         TOT_REV,
         TOT_AB,
         TOT_EXP,
         NUM_CCN,
         NUM_TIN)
```

```{r 7 }
#7.	Create a new variable METHODOLOGY set equal to “Benchmark-based” for all records.

ACO_benchmark = ACO_benchmark %>% 
  mutate(METHODOLOGY = "Benchmark-based")
```

```{r 8}
#8.	Merge on other ACO-level variables, by ACO_ID (but only include ACOs from the ACO/TIN crosswalk)
  #a.	TRACK (From ACO/TIN crosswalk)
  #b.	PROGRAM_YEAR (From ACO/TIN crosswalk)
  #c.	Latest_Agreement_Start_Date (From ACO/TIN crosswalk)
  #d.	Renewal_Effective_Date (From ACO/TIN crosswalk)
    #i.	May be missing for some ACOs
  #e.	ACO_START_DATE (From ACO/TIN Crosswalk)
  #f.	INTO_RISK (From ACO/TIN Crosswalk)
  #h.	RISK
    #i.	RISK variable must be calculated using the TRACK variable according to the following coding scheme: 
      #1.	If TRACK is 1+, 2, 3, C, D, E, or EN:
         #a.	RISK = “Yes”
      #2.	If TRACK is 1, A, or B:
         #a.	RISK = “No”
  #i.	REPAY_CURRENT (From REPAY_CURRENT dataset)
    #i.	If ACO is not in the REPAY_CURRENT dataset, set variable REPAY_CURRENT equal to missing
  #j.	TRACK_1_PLUS_CURRENT_COMPOSITION (From TRACK_1_PLUS_COMP_DATASET)
    #i.	If ACO is not in the TRACK_1_PLUS_COMP_DATASET, set variable  TRACK_1_PLUS_CURRENT_COMPOSITION equal to missing
  #k.	TRACK_1+_LOSS_LIMIT_CHANGE (From TRACK_1_PLUS_COMPOSITION_CHANGE dataset)


  #a
ACO_benchmark <- ACO_benchmark %>% 
  #a - f
  left_join(acoData, by = "ACO") %>% 
  #h
  left_join(trackRisk, by = "TRACK") %>% 
  #i
  left_join(repay,by=c("ACO"="ACO")) %>%
  #j
  left_join(Track_1_plus_status,by=c("ACO"="ACO.ID")) %>% 
  #k
  left_join(Track_1_plus_change,by=c("ACO"="ACO.ID"))
  

  






```


```{r 9}

# 9.	Create a duplicate version of data set created in Step (6).
#   a.	In this version, set METHODOLOGY equal to "Revenue-based".

ACO_revenue <- as_tibble(ACO_benchmark) %>%
  mutate(METHODOLOGY = "Revenue-based")


```

```{r 10}

# 10.	Stack the data sets from Step (8) and Step (9).
#   a.	The resulting data set will include two ACO-level records and two records for each ACO/TIN combination.
#   b.	Generate a variable TIN = “Total/Average”
ACO <- bind_rows(ACO_revenue, ACO_benchmark) %>%
  select(everything(), ASSIGNED = TOT_AB) %>% 
  mutate(TIN = "Total/Average")



```


```{r 9a helper funcs}

#Helper functions for calculating dollars per beneficiary and projected dollers per bene


#	DOLLAR_PER_BENE:
      #1.	If ASSIGNED > 0 and METHODOLOGY = "Benchmark-based", DOLLAR_PER_BENE = TOT_EXP/ASSIGNED
      #2.	 If ASSIGNED > 0 and METHODOLOGY = "Revenue-based", DOLLAR_PER_BENE = TOT_REV/ASSIGNED
      #3.	If ASSIGNED = 0, DOLLAR_PER_BENE = missing
dollarPerBeneFn <- Vectorize(function(ASSIGNED, METHODOLOGY, TOT_EXP, TOT_REV){
  if(ASSIGNED > 0 & METHODOLOGY == "Benchmark-based"){
    return (TOT_EXP / ASSIGNED)
  }
  if (ASSIGNED > 0 & METHODOLOGY == "Revenue-based"){
    return (TOT_REV / ASSIGNED)
  }
  if (ASSIGNED == 0){return (NA)}
}
)


#	PROJ_DOLLAR_PER_BENE:
    #1.	If ASSIGNED > 0, PROJ_DOLLAR_PER_BENE = DOLLAR_PER_BENE * DOLLAR_TREND
    #2.	If ASSIGNED = 0, PROJ_DOLLAR_PER_BENE = missing
projDollPerBeneFn <- Vectorize(function(ASSIGNED, DOLLAR_PER_BENE, DOLLAR_TREND){
  if(ASSIGNED > 0){
    return(DOLLAR_PER_BENE * DOLLAR_TREND)
  }
  if(ASSIGNED == 0){
    return(NA)
  }
})


#	PROJ_TOT_DOLLAR:
    #1.	If METHODOLOGY = "Benchmark-based":
      #a.	PROJ_TOT_DOLLAR = TOT_EXP * ASSG_GROWTH * DOLLAR_TREND
    #2.	If METHODOLOGY = "Revenue-based":
      #a.	PROJ_TOT_DOLLAR = TOT_REV * ASSG_GROWTH * DOLLAR TREND
projTotDollFn <- Vectorize(function(ASSIGNED, ASSG_GROWTH, METHODOLOGY, TIN, TOT_EXP, TOT_REV, DOLLAR_TREND){
  if (METHODOLOGY == "Benchmark-based"){
    
      return(TOT_EXP * ASSG_GROWTH * DOLLAR_TREND)
    
  }
  
  if (METHODOLOGY == "Revenue-based"){
    
      return(TOT_REV * ASSG_GROWTH * DOLLAR_TREND)
    
  }
})

#	PROJ_TOT_EXP:
    #1.	If (0 < ASSIGNED * ASSG_GROWTH < 5000) and (TIN = "Total/Average"):
      #a.	PROJ_TOT_EXP = TOT_EXP * ASSG_GROWTH * DOLLAR TREND
projTotExpFn <- Vectorize(function(ASSIGNED, ASSG_GROWTH, TIN, TOT_EXP, DOLLAR_TREND){
  
    return(TOT_EXP * ASSG_GROWTH * DOLLAR_TREND)
  
})



#	PROJ_TOT_REV:
    #1.	If (0 < ASSIGNED * ASSG_GROWTH < 5000) and (TIN = "Total/Average"):
      #a.	PROJ_TOT_REV = TOT_REV * ASSG_GROWTH * DOLLAR TREND
projTotRevFn <- Vectorize(function(ASSIGNED, ASSG_GROWTH, TIN, TOT_REV, DOLLAR_TREND){
  
    return(TOT_REV * ASSG_GROWTH * DOLLAR_TREND)
  }
)






#	REQ_PCT:
#  1.	If METHODOLOGY = “Benchmark-based”, REQ_PCT = 0.01
#  2.	If METHODOLOGY = “Revenue-based”, REQ_PCT = 0.02
reqPctFn <- Vectorize(function(METHODOLOGY){
  if(METHODOLOGY == "Benchmark-based"){return(0.01)}
  if(METHODOLOGY == "Revenue-based"){return(0.02)}
})




#	PROJ_ASSIGNED:
    #1.	If (0 < ASSIGNED * ASSG_GROWTH < 5000) and (TIN = "Total/Average"):
      #a.	PROJ_ASSIGNED = 5000
    #2.	Else:
      #a.	PROJ_ASSIGNED = ASSIGNED * ASSG_GROWTH
projAssignFn <- Vectorize(function(ASSIGNED, ASSG_GROWTH, TIN){
  projAssg <- ASSIGNED * ASSG_GROWTH
  
  return(projAssg)
  
})





#	INITIAL_DETER_RM_AMT:
#1.	If ASSIGNED >0 & TRACK not in (1+,2,3):
    #a.	INITIAL_DETER_RM_AMT = Minimum of (FCST_RM_AMT_EXP, FCST_RM_AMT_REV)
#2.	If ASSIGNED >0 & TRACK = "1+" & TRACK_1_PLUS_CURRENT_COMPOSITION ="Benchmark":
    #a.	INITIAL_DETER_RM_AMT = FCST_RM_AMT_EXP
#3.	If ASSIGNED >0 & TRACK = "1+" & TRACK_1_PLUS_CURRENT_COMPOSITION ="Revenue":
    #a.	INITIAL_DETER_RM_AMT = Min(FCST_RM_AMT_REV, FCST_RM_AMT_EXP)
#4.	If ASSIGNED > 0 & TRACK in (2,3):
    #a.	INITIAL_DETER_RM_AMT = REPAY_CURRENT
#5.	If ASSIGNED = 0:
    #a.	INITIAL_DETER_RM_AMT = FCST_RM_AMT_REV
initDeterFn = Vectorize(function(ASSIGNED, TRACK, TRACK_1_PLUS_CURRENT_COMPOSITION, FCST_RM_AMT_EXP, FCST_RM_AMT_REV, REPAY_CURRENT, SCENARIO){
  INITIAL_DETER_RM_AMT = c()
  INITIAL_SCENARIO=c()
  if(ASSIGNED > 0 & !(TRACK %in% c("2", "1+", "3"))) {
  INITIAL_DETER_RM_AMT = min(FCST_RM_AMT_EXP, FCST_RM_AMT_REV)
  INITIAL_SCENARIO="non track 2,3,1+"
  }
  else if(ASSIGNED > 0 & TRACK == "1+" & TRACK_1_PLUS_CURRENT_COMPOSITION=="Benchmark"){
    INITIAL_DETER_RM_AMT = FCST_RM_AMT_EXP
    INITIAL_SCENARIO='1+, benchmark-based'
  }
  else if(ASSIGNED > 0 & TRACK == "1+" & TRACK_1_PLUS_CURRENT_COMPOSITION=="Revenue"){
    INITIAL_DETER_RM_AMT = min(FCST_RM_AMT_EXP, FCST_RM_AMT_REV)
    INITIAL_SCENARIO='1+, revenue-based'
  }  
  
  else if(ASSIGNED > 0 & TRACK %in% c("2", "3")){
    INITIAL_DETER_RM_AMT = REPAY_CURRENT
    INITIAL_SCENARIO='track 2,3'
  }
  else if(ASSIGNED==0){
    INITIAL_DETER_RM_AMT = FCST_RM_AMT_REV
    INITIAL_SCENARIO='0 assigned'
  }

  else{
    INITIAL_DETER_RM_AMT = FCST_RM_AMT_REV
    INITIAL_SCENARIO="Initial Error"
  }
  if (SCENARIO==TRUE){
    return(INITIAL_SCENARIO)
  }
  else{
    return(INITIAL_DETER_RM_AMT)
  }
 }
)






#	ACO_CATEGORY
#2.	If LATEST_AGREEMENT_START_DATE in (7/1/2019, 1/1/2020) & RISK = ”Yes”, ACO_CATEGORY= “basic_enhanced_two_sided”
  #a.	Note that these are ACOs that are continuing in an agreement period started July 1, 2019 or January 1, 2020 that will be participating in a two-sided risk model in 2021.

#3.	If LATEST_AGREEMENT_START_DATE in (1/1/2019, 1/1/2018) & RISK = ”Yes”, ACO_CATEGORY= “pre_basic_enhanced_two_sided”
  #a.	Note that these are ACOs that are continuing in an agreement period started January 1, 2018 or January 1, 2019 that will be participating in a two-sided risk model in 2021.

#4.	Otherwise ACO_CATEGORY = “non_two_sided”
  #a.	Note that these are ACOs that are applying for, or will be continuing in, a one-sided risk-model in 2021.



ACO_category_fn = Vectorize(function(Latest_Agreement_Start_Date, RISK, INTO_RISK){

  if(Latest_Agreement_Start_Date %in% c("2019-07-01", "2020-01-01") & RISK == "Yes" & INTO_RISK==1){
    return("basic_enhanced_into_two_sided")
  }
  else if(Latest_Agreement_Start_Date %in% c("2019-07-01", "2020-01-01") & RISK == "Yes" & INTO_RISK==0){
    return("basic_enhanced_maintain_two_sided")
  }  
  else if(Latest_Agreement_Start_Date %in% c("2019-01-01", "2018-01-01")  & RISK == "Yes"){
    return("pre_basic_enhanced_two_sided")
  }
  else{
    return("non_two_sided")
  }
})

#	HI_LOW_RATIO = PROJ_TOT_REV/PROJ_TOT_EXP
hiLowFn <- Vectorize(function(HI_LOW_RATIO){
  if(is.na(HI_LOW_RATIO) | HI_LOW_RATIO == Inf){return(NA)}
  if(HI_LOW_RATIO >= .35){return("High Revenue")}
  if(HI_LOW_RATIO < .35){return("Low Revenue")}
  
})



```



```{r 9a Calculate required payment amount, RM ACTION, and Threshold}
REQ_ACTION_THRESHOLD_fn = Vectorize(function(ACO_CATEGORY, RENEWING_ACO, REPAY_CURRENT, INITIAL_DETER_RM_AMT, TRACK, variable, TRACK_1_PLUS_LOSS_LIMIT_CHANGE ){
##  Basic/Enhanced Two Sided ACOs maintaining risk
#  .	Scenario 1: ACO_CATEGORY= "basic_enhanced_two_sided & REPAY_CURRENT is not missing & [(INITIAL_DETER_RM_AMT >= 1.5 x REPAY_CURRENT) OR (INITIAL_DETER_RM_AMT >= (1,000,000 + REPAY_CURRENT))]
      #o	REQ_RM_AMT = INITIAL_DETER_RM_AMT
      #o	RM_ACTION = "Contact your ACO Coordinator, ACO met threshold for potential RM increase"
      #o	THRESHOLD_EXCEEDED = "Yes (Increase)"

#.	Scenario 2:  ACO_CATEGORY= "basic_enhanced_two_sided & REPAY_CURRENT is not missing & (INITIAL_DETER_RM_AMOUNT < 1.5 x REPAY_CURRENT) & (INITIAL_DETER_RM_AMOUNT < (1,000,000 + REPAY_CURRENT))
      #o	REQ_RM_AMT = REPAY_CURRENT
      #o	RM_ACTION = "None. No change needed to existing RM amount."
      #o	THRESHOLD_EXCEEDED = "No"

#.	Scenario 3: ACO_CATEGORY= "basic_enhanced_two_sided & REPAY_CURRENT is missing
      #o	REQ_RM_AMT = INITIAL_DETER_RM_AMT
      #o	RM_ACTION = "Establish RM at required RM amount."
      #o	THRESHOLD_EXCEEDED = "Not Applicable"


    if(ACO_CATEGORY=="basic_enhanced_maintain_two_sided" & !is.na(REPAY_CURRENT) & (INITIAL_DETER_RM_AMT >= (1.5 * REPAY_CURRENT) | INITIAL_DETER_RM_AMT >= (1E6 + REPAY_CURRENT))){
    REQ_RM_AMT = INITIAL_DETER_RM_AMT
    Message = "Contact your ACO Coordinator, ACO met threshold for potential RM increase"
    Threshold = "Yes (Increase)"
    REQ_SCENARIO = 'basic_enhanced_maintain_two_sided_1'
    }
    else if(ACO_CATEGORY=="basic_enhanced_maintain_two_sided" & !is.na(REPAY_CURRENT) & (INITIAL_DETER_RM_AMT < (1.5 * REPAY_CURRENT) & INITIAL_DETER_RM_AMT < (1E6 + REPAY_CURRENT))){
    REQ_RM_AMT = REPAY_CURRENT
    Message = "None. No change needed to existing RM amount"
    Threshold = "No"
    REQ_SCENARIO = 'basic_enhanced_maintain_two_sided_2'
    }
    
    else if(ACO_CATEGORY=="basic_enhanced_maintain_two_sided" & is.na(REPAY_CURRENT) ){
    REQ_RM_AMT = INITIAL_DETER_RM_AMT
    Message = "Establish RM at required RM amount"
    Threshold = "Not Applicable"
    REQ_SCENARIO = 'basic_enhanced_maintain_two_sided_3'
    }
  
  
  
 ##  Basic/Enhanced Two Sided ACOs moving into risk
  #
#•	Scenario 1: ACO_CATEGORY= “basic_enhanced_into_two_sided” 
      #o	REQ_RM_AMT = INITIAL_DETER_RM_AMT
      #o	RM_ACTION = "None. RM requirement already established."
      #o	THRESHOLD_EXCEEDED = "Not Applicable"


  
    else if(ACO_CATEGORY=="basic_enhanced_into_two_sided" ){
    REQ_RM_AMT = INITIAL_DETER_RM_AMT
    Message = "None. RM requirement already established."
    Threshold = "Not Applicable"
    REQ_SCENARIO = 'basic_enhanced_into_two_sided_1'
    }
  
  
  
  
  ## Pre Basic/Enhanced two sided ACOs
#•	Scenario 1: ACO_CATEGORY= “pre_basic_enhanced_two_sided” & TRACK="1+" & TRACK_1+_LOSS_LIMIT_CHANGE =1 &[(INITIAL_DETER_RM_AMT >= 1.5 x REPAY_CURRENT) OR (INITIAL_DETER_RM_AMT >= (1,000,000 + REPAY_CURRENT))]
      #o	REQ_RM_AMT = INITIAL_DETER_RM_AMT
      #o	RM_ACTION = "Contact your ACO coordinator, ACO met threshold for potential RM increase"
      #o	THRESHOLD_EXCEEDED = "Yes (Increase)"

#•	Scenario 2:  ACO_CATEGORY= “basic_enhanced_maintain_two_sided”  & REPAY_CURRENT is not missing & TRACK_1+_LOSS_LIMIT_CHANGE =1  & (INITIAL_DETER_RM_AMOUNT < 1.5 x REPAY_CURRENT) & (INITIAL_DETER_RM_AMOUNT < (1,000,000 + REPAY_CURRENT))
     #o	REQ_RM_AMT = REPAY_CURRENT
     #o	RM_ACTION = "None. No change needed to existing RM amount"
     #o	THRESHOLD_EXCEEDED = "No"
#•	Scenario 3: ACO_CATEGORY= “pre_basic_enhanced_two_sided” & TRACK="1+" & TRACK_1+_LOSS_LIMIT_CHANGE =0
     #o	REQ_RM_AMT = REPAY_CURRENT
     #o	RM_ACTION = "None. No change needed to existing RM amount"
     #o	THRESHOLD_EXCEEDED = "Not Applicable"
#•	Scenario 4: ACO_CATEGORY= “pre_basic_enhanced_two_sided” & TRACK<>"1+"
    #o	REQ_RM_AMT = REPAY_CURRENT
    #o	RM_ACTION = "None. For Informational purposes only"
    #o	THRESHOLD_EXCEEDED = "Not Applicable"


    else if(ACO_CATEGORY=="pre_basic_enhanced_two_sided" & TRACK == "1+" &  TRACK_1_PLUS_LOSS_LIMIT_CHANGE == "Yes" &
            (INITIAL_DETER_RM_AMT >= (1.5 * REPAY_CURRENT) | INITIAL_DETER_RM_AMT >= (1E6 + REPAY_CURRENT))){
    REQ_RM_AMT = INITIAL_DETER_RM_AMT
    Message = "Contact your ACO Coordinator, ACO met threshold for potential RM increase."
    Threshold = "Yes (Increase)"
    REQ_SCENARIO = 'pre_july_two_sided_1'
    }

    else if(ACO_CATEGORY=="pre_basic_enhanced_two_sided" & TRACK == "1+" &  TRACK_1_PLUS_LOSS_LIMIT_CHANGE == "Yes" &
            (INITIAL_DETER_RM_AMT <= (.5 * REPAY_CURRENT) | INITIAL_DETER_RM_AMT <= (REPAY_CURRENT - 1E6))){
    REQ_RM_AMT = REPAY_CURRENT
    Message = "Contact your ACO coordinator, ACO may be eligible for an RM decrease"
    Threshold = "Yes (Possible Decrease)"
    REQ_SCENARIO = 'pre_july_two_sided_2'
    }
  
    else if(ACO_CATEGORY=="pre_basic_enhanced_two_sided" & TRACK == "1+" &  TRACK_1_PLUS_LOSS_LIMIT_CHANGE == "Yes" &
            (INITIAL_DETER_RM_AMT > (.5 * REPAY_CURRENT) & INITIAL_DETER_RM_AMT > (REPAY_CURRENT - 1E6)) &
            (INITIAL_DETER_RM_AMT < (1.5 * REPAY_CURRENT) & INITIAL_DETER_RM_AMT < (1E6 + REPAY_CURRENT))){
    REQ_RM_AMT = REPAY_CURRENT
    Message = "None. No change needed to existing RM amount"
    Threshold = "No"
    REQ_SCENARIO = 'pre_july_two_sided_3'
    }   
  
    else if(ACO_CATEGORY=="pre_basic_enhanced_two_sided" & TRACK == "1+" &  TRACK_1_PLUS_LOSS_LIMIT_CHANGE == "No" 
            ){
    REQ_RM_AMT = REPAY_CURRENT
    Message = "None. No change needed to existing RM amount"
    Threshold = "Not Applicable"
    REQ_SCENARIO = 'pre_july_two_sided_4'
    }   

      else if(ACO_CATEGORY=="pre_basic_enhanced_two_sided" & TRACK != "1+"
            ){
    REQ_RM_AMT = REPAY_CURRENT
    Message = "For Information Only. No RM Adjustment Required"
    Threshold = "Not Applicable"
    REQ_SCENARIO = 'pre_july_two_sided_5'
    }   
  
  
  
  
  
  
  
## non risk ACOs    
#  .	Scenario 1: ACO_CATEGORY = "non_two_sided" 
      #o	  REQ_RM_AMT = INITIAL_DETER_RM_AMT
      #o	  RM_ACTION = "None. For Informational purposes only"
      #o	  THRESHOLD_EXCEEDED = "Not Applicable" 

   else if (ACO_CATEGORY=="non_two_sided"){
    REQ_RM_AMT = INITIAL_DETER_RM_AMT
    Message = "For Information Only. No RM Adjustment Required"
    Threshold = "Not Applicable" 
    REQ_SCENARIO = 'non_risk'
      
   }

  
## Should be none in this category    
  else{
    REQ_RM_AMT = NA
    Message = NA
    Threshold = NA
    REQ_SCENARIO = "not found"    
    
  }

#determine which metric output by function
  if(variable=='REQ_RM_AMT')
  return(REQ_RM_AMT)
 
else if(variable=='Message'){
  return(Message)
}
else if(variable=='Threshold'){
  return(Threshold)
}
else if(variable=='Req_Scenario'){
  return(REQ_SCENARIO)
}    
      
})




```


```{r 9a outputs }

#Generate output using helper functions
output <- ACO %>%
  ungroup() %>%
  mutate(ASSG_GROWTH = 1.03136,
         
         PROJ_ASSIGNED = projAssignFn(ASSIGNED, ASSG_GROWTH, TIN),
         
         DOLLAR_PER_BENE = dollarPerBeneFn(ASSIGNED, METHODOLOGY, TOT_EXP, TOT_REV),
         
         DOLLAR_TREND = 1.09663,
         
         PROJ_DOLLAR_PER_BENE = projDollPerBeneFn(ASSIGNED, DOLLAR_PER_BENE, DOLLAR_TREND),
         
         PROJ_TOT_DOLLAR = projTotDollFn(ASSIGNED, ASSG_GROWTH, METHODOLOGY, TIN, TOT_EXP, TOT_REV, DOLLAR_TREND),
         
         PROJ_TOT_EXP = projTotExpFn(ASSIGNED, ASSG_GROWTH, TIN, TOT_EXP, DOLLAR_TREND),
         
         PROJ_TOT_REV = projTotRevFn(ASSIGNED, ASSG_GROWTH, TIN, TOT_REV, DOLLAR_TREND),
         
         REQ_PCT = reqPctFn(METHODOLOGY),
         
         FCST_RM_AMT = PROJ_TOT_DOLLAR * REQ_PCT,
         
         FCST_RM_AMT_EXP = PROJ_TOT_EXP * 0.01,
         
         FCST_RM_AMT_REV = PROJ_TOT_REV * 0.02,
         
         INITIAL_DETER_RM_AMT = initDeterFn(ASSIGNED, TRACK, TRACK_1_PLUS_CURRENT_COMPOSITION, FCST_RM_AMT_EXP, FCST_RM_AMT_REV, REPAY_CURRENT, SCENARIO=FALSE),
         
         INITIAL_SCENARIO = initDeterFn(ASSIGNED, TRACK, TRACK_1_PLUS_CURRENT_COMPOSITION, FCST_RM_AMT_EXP, FCST_RM_AMT_REV, REPAY_CURRENT, SCENARIO=TRUE),
         
         RENEWING_ACO =  if_else(ACO_START_DATE != "2021-01-01" & Latest_Agreement_Start_Date=="2021-01-01","Yes","No"),

         ACO_CATEGORY = ACO_category_fn(Latest_Agreement_Start_Date, RISK, INTO_RISK),
         
         REQ_RM_AMT = REQ_ACTION_THRESHOLD_fn(ACO_CATEGORY, RENEWING_ACO, REPAY_CURRENT, INITIAL_DETER_RM_AMT, TRACK,variable='REQ_RM_AMT', TRACK_1_PLUS_LOSS_LIMIT_CHANGE),
         
         RM_ACTION = REQ_ACTION_THRESHOLD_fn(ACO_CATEGORY, RENEWING_ACO, REPAY_CURRENT, INITIAL_DETER_RM_AMT,  TRACK, variable='Message', TRACK_1_PLUS_LOSS_LIMIT_CHANGE),
         
         THRESHOLD_EXCEEDED  = REQ_ACTION_THRESHOLD_fn(ACO_CATEGORY, RENEWING_ACO, REPAY_CURRENT, INITIAL_DETER_RM_AMT, TRACK,variable='Threshold', TRACK_1_PLUS_LOSS_LIMIT_CHANGE),
         
         REQ_SCENARIO = REQ_ACTION_THRESHOLD_fn(ACO_CATEGORY, RENEWING_ACO, REPAY_CURRENT, INITIAL_DETER_RM_AMT, TRACK, variable='Req_Scenario', TRACK_1_PLUS_LOSS_LIMIT_CHANGE),
         
         HI_LOW_RATIO = PROJ_TOT_REV/PROJ_TOT_EXP,
         
         ACO_HI_LOW_REV = hiLowFn(HI_LOW_RATIO))


#Examine output. This is just an interactive area to look
output %>% group_by(TRACK_1_PLUS_LOSS_LIMIT_CHANGE) %>% count()
output %>% group_by(ACO_CATEGORY) %>% count()
output %>% group_by(INITIAL_SCENARIO) %>% count()
output %>% filter(TIN == "Total/Average" & METHODOLOGY == "Benchmark-based") %>% mutate(total_count = n()) %>% group_by(REQ_SCENARIO) %>% mutate(group_count = n()) %>% slice(1) %>% select(REQ_SCENARIO,total_count, group_count) %>% ungroup() %>% mutate(sum_group = sum(group_count))
                                                                                                                                                  
filter = output %>% filter(REQ_SCENARIO== "basic_enhanced_maintain_two_sided_1", METHODOLOGY == "Benchmark-based") %>% select(ACO, REPAY_CURRENT, INITIAL_DETER_RM_AMT) %>% mutate(diff = INITIAL_DETER_RM_AMT - REPAY_CURRENT)

Previous_file = read_excel("Z:\\participant management\\prescreening\\2021 Prescreening\\Batch G3\\Participation Options Report\\Participation_Options_PY2021_Final_Round_20201019.xlsx", sheet = 3) %>% filter(`ACO Participant TIN` == "Total/Average", `Benchmark- or Revenue-Based` == "Benchmark-based") %>% 
  select(`ACO ID`, `Initial Determined Repayment Mechanism Amount`, `Repayment Mechanism Amount Action Required`, `Existing Repayment Mechanism Amount`)

filter = filter %>% left_join(Previous_file, by=c("ACO" = "ACO ID")) %>% mutate(diff_initial = (INITIAL_DETER_RM_AMT - `Initial Determined Repayment Mechanism Amount`)/`Initial Determined Repayment Mechanism Amount`,
                                                                                diff_existing = (REPAY_CURRENT - `Existing Repayment Mechanism Amount`)/`Existing Repayment Mechanism Amount`)
```


```{r Create CMS file}


# Create functions to blank particular columns


#11b.	For certain variables created in Step (9a), only keep values for the Benchmark-based ACO-level record:      
        ##i.	If METHODOLOGY = “Revenue-based” or TIN <> “Total/Average”, set the following variables equal to missing:
          #1.	RISK
          #2.	REPAY_CURRENT
          #3	INITIAL_DETER_RM_AMT
          #4	TRACK_1+_LOSS_LIMIT_CHANGE
          #5.	THRESHOLD_EXCEEDED
          #6.	REQ_RM_AMT
          #7.	RM_ACTION
          #8.	HI_LOW_RATIO
          #9.	ACO_HI_LOW_REV
blankFn <- Vectorize(function(input, METHODOLOGY, TIN){
  if(METHODOLOGY == "Revenue-based" | TIN != "Total/Average"){
    return(NA)
  }else{return(input)}
})




#11b
outputBlanked_CMS <- output %>%
  mutate(
    
    


         # Blanking risk-related columns for Revenue & TIN rows (has to be done bc only want to show this info once per ACO)
         RISK = blankFn(RISK, METHODOLOGY, TIN),
         REPAY_CURRENT = blankFn(REPAY_CURRENT, METHODOLOGY, TIN),
         INITIAL_DETER_RM_AMT = blankFn(INITIAL_DETER_RM_AMT, METHODOLOGY, TIN),
         TRACK_1_PLUS_LOSS_LIMIT_CHANGE = blankFn(TRACK_1_PLUS_LOSS_LIMIT_CHANGE, METHODOLOGY, TIN),
         THRESHOLD_EXCEEDED = blankFn(THRESHOLD_EXCEEDED, METHODOLOGY, TIN),
         REQ_RM_AMT = blankFn(REQ_RM_AMT, METHODOLOGY, TIN),
         RM_ACTION = blankFn(RM_ACTION, METHODOLOGY, TIN),
         HI_LOW_RATIO = blankFn(HI_LOW_RATIO, METHODOLOGY, TIN),
         ACO_HI_LOW_REV = blankFn(ACO_HI_LOW_REV, METHODOLOGY, TIN)


    )

#11c.	Sort the data as follows:
        #i.	First by ACO_ID
        #ii.	Second by METHODOLOGY (alphabetically, so “Benchmark-based” appears first)
        #iii.	For each ACO_ID/METHODOLOGY combination, the ACO-level record (TIN = “Total/Average”) should appear first, and then TIN-level records (TIN <> “Total/Average”) should be sorted by TIN. 

tinSortFn <- Vectorize(function(TIN){
  if(TIN == "Total/Average"){return(0)}else{return(as.numeric(TIN))}
})

outputBlankedSorted_CMS <- outputBlanked_CMS %>%
  mutate(overall = (TIN == "Total/Average"),
         tinSort = tinSortFn(TIN)) %>%
  arrange(ACO, METHODOLOGY, -overall, tinSort)


#11d.	Make the following additional manipulations to the data:
       ##i.	REQ_PCT: multiply by 100 so value is either 1 or 2.
       ##ii.	HI_LOW_RATIO: multiply by 100, then truncate to two decimal places (do not round in order to keep displayed value consistent with high/low revenue ACO determination)
       ##iii.	If ASSIGNED = 0, set ACO_HI_LOW_REV to missing.

#11e.	For all rows in dataset, set PROGRAM_YEAR = 2021
#11f.	Keep the only the variables listed in the table below. The variables should appear in the data set in this order (which is the order they will appear in the template), with the listed labels and formats applied (number in parentheses represents number of decimal places for rounding numeric variables):

outputFinal_CMS <- as_tibble(outputBlankedSorted_CMS) %>%
  
  mutate(ASSIGNED = as.numeric(round(ASSIGNED, 5)),
         ASSG_GROWTH = as.numeric(round(ASSG_GROWTH, 5)),
         PROJ_ASSIGNED = as.numeric(round(PROJ_ASSIGNED, 0)),
         DOLLAR_PER_BENE  = round(DOLLAR_PER_BENE, 2),
         DOLLAR_TREND = as.numeric(round(DOLLAR_TREND, 5)),
         PROJ_DOLLAR_PER_BENE = as.numeric(round(PROJ_DOLLAR_PER_BENE, 2)),
         PROJ_TOT_DOLLAR = as.numeric(round(PROJ_TOT_DOLLAR, 2)),
         REQ_PCT = as.numeric(round(REQ_PCT * 100, 2)),
         FCST_RM_AMT = as.numeric(round(FCST_RM_AMT, 0)), 
         REPAY_CURRENT = as.numeric(round(REPAY_CURRENT, 0)),
         INITIAL_DETER_RM_AMT = as.numeric(round(INITIAL_DETER_RM_AMT, 0)),
         REQ_RM_AMT = as.numeric(round(REQ_RM_AMT, 0)),
         HI_LOW_RATIO = as.numeric(floor(HI_LOW_RATIO * 10000) / 100),
         PROGRAM_YEAR = '2021') %>%
  
# name variables
  select("ACO ID" = ACO, 
         "Program Year" = PROGRAM_YEAR,
         "ACO Participant TIN" = TIN,
         "Benchmark- or Revenue-Based" = METHODOLOGY,
         Track = TRACK,
         "2019 Assigned Beneficiaries (A)" = ASSIGNED,
         "Assignment Growth (B)" = ASSG_GROWTH,
         "Projected 2021 Assigned Beneficiaries (C)" = PROJ_ASSIGNED,
         "2019 Dollars per Beneficiary (D)" = DOLLAR_PER_BENE,
         "Dollar Trend (E)" = DOLLAR_TREND,
         "Projected 2021 Dollars per Beneficiary (F)" = PROJ_DOLLAR_PER_BENE,
         "Projected 2021 Total Dollars (G)" = PROJ_TOT_DOLLAR,
         "Required Percentage (H)" = REQ_PCT, 
         "Forecast Repayment Mechanism Amount (I)" = FCST_RM_AMT,
         "Performance-Based Risk Track (J)" = RISK,
         "Existing Repayment Mechanism Amount (K)" = REPAY_CURRENT,
         "Initial Determined Repayment Mechanism Amount (L)" = INITIAL_DETER_RM_AMT,
         "Track 1+ Loss Limit Composition Changed (M)" = TRACK_1_PLUS_LOSS_LIMIT_CHANGE,
         "Met Threshold to Update Repayment Mechanism Amount (N)" = THRESHOLD_EXCEEDED,
         "Required Repayment Mechanism Amount (O)" = REQ_RM_AMT,
         "Repayment Mechanism Amount Action Required (P)" = RM_ACTION,
         "Revenue as Percent of Expenditures (Q)" = HI_LOW_RATIO,
         "High or Low Revenue ACO Determination (R)" = ACO_HI_LOW_REV
         )



#replace improper Hi Low revenue value
outputFinal_CMS$`Revenue as Percent of Expenditures (Q)`[outputFinal_CMS$`Revenue as Percent of Expenditures (Q)`==Inf] = ""

#don't need step 9g because these are the data export steps

openxlsx::write.xlsx(outputFinal_CMS, "Z:\\finance\\participant revenue and expenditures\\2021 Cycle\\Validation_output\\Final_High_Low_validation.xlsx")

```



```{r Keith Compare}

# This section allows comparison to Round 1 Final Data



Keith_data = read_excel("Z:\\pgm output\\ACOV2-5171\\Keith\\ACO5171_CMSxpt_Prod.xlsx", sheet=1) 

#merge together
check_data<-inner_join(outputFinal_CMS,Keith_data,by=c("ACO ID" = "ACOID","ACO Participant TIN" = 'TIN',"Benchmark- or Revenue-Based"="Benchmark- or Revenue-Based"))
names(check_data)

#This should have zero rows. Datasets should have same ACO/TIN combinations
total_match<-anti_join(outputFinal_CMS,Keith_data,by=c("ACO ID" = "ACOID","ACO Participant TIN" = 'TIN',"Benchmark- or Revenue-Based"="Benchmark- or Revenue-Based"))


#replace missing and NA with a distinctive value for matching. This is to allow boolean comparisons in situations where data is missing
check_data[,]<-lapply(check_data[,],function(x) ifelse(x=="","-999999999",x))
check_data[,]<-lapply(check_data[,],function(x) ifelse(is.na(x) & is.character(x),"-999999999",x))
check_data[,]<-lapply(check_data[,],function(x) ifelse(is.na(x) & is.numeric(x),-999999999,x))
names(check_data)

#make string to lower for comparison
check_data$action_x = gsub(" ", "", tolower(check_data$`Repayment Mechanism Amount Action Required (P)`))
check_data$action_y = gsub(" ", "", tolower(check_data$`Repayment Mechanism Action Required`))
check_data$action_x = gsub("[.]", "", check_data$action_x)
check_data$action_y = gsub("[.]", "", check_data$action_y)
check_data$action_x = gsub("-", "", check_data$action_x)
check_data$action_y = gsub("-", "", check_data$action_y)


library(quantmod)
names(check_data)

check_data<-check_data %>% 
  mutate(check_assigned=`2019 Assigned Beneficiaries (A)`==`2018 Assigned Beneficiaries` ,
         
         check_assg_growth=round(`Assignment Growth (B)`,1)==round(`Assignment Growth`,1),
         
         check_proj_2021_benes=if_else(`Projected 2021 Assigned Beneficiaries (C)` == 0, `Projected 2021 Assigned Beneficiaries (C)` == `Projected 2021 Assigned Beneficiaries`, abs(Delt(`Projected 2021 Assigned Beneficiaries (C)`,`Projected 2021 Assigned Beneficiaries`)) < .0001),
         
         check_Doll_per_bene=Delt(as.numeric(`2019 Dollars per Beneficiary (D)`),as.numeric(`2019 Dollars per Beneficiary`))<.0001,
         
         check_trend_dollar=round(as.numeric(`Dollar Trend (E)`),1)==round(as.numeric(`Dollar Trend`),1),
         
         check_Proj_Doll_per_bene=abs(Delt(as.numeric(`Projected 2021 Dollars per Beneficiary (F)`),as.numeric(`Projected 2021 Dollars per Beneficiary`)))<.001,
         
         check_Proj_Total_Dollars= if_else(`Projected 2021 Total Dollars (G)` == 0, `Projected 2021 Total Dollars (G)` == `Projected 2021 Total Dollars`, abs(Delt(as.numeric(`Projected 2021 Total Dollars (G)`),as.numeric(`Projected 2021 Total Dollars (G)`)))<.0001),
         
         check_req_perc=round(`Required Percentage (H)`,1)==round(`Required Percentage`,1),
         
         check_forecast_repay=if_else(`Forecast Repayment Mechanism Amount (I)` == 0, `Forecast Repayment Mechanism Amount (I)` == `Forecast Repayment Mechanism Amount`,abs(Delt(`Forecast Repayment Mechanism Amount (I)`,`Forecast Repayment Mechanism Amount`))<.001),
         
         check_risk_track=`Performance-Based Risk Track (J)`==`Performance-Based Risk Track`,
         
         check_existing_repay_amt=round(as.numeric(`Existing Repayment Mechanism Amount (K)`),0)==round(as.numeric(`Existing Repayment Mechanism Amount`),0),
         
         check_Initial_Repay_amt=abs(Delt(as.numeric(`Initial Determined Repayment Mechanism Amount (L)`),as.numeric(`Initial Determined Repayment Mechanism Amount`)))<.0001,
         
         check_track_1plus_ll = `Track 1+ Loss Limit Composition Changed (M)` == `Track 1+ Loss Limit Composition Changed`,
         
         check_met_threshold = `Met Threshold to Update Repayment Mechanism Amount (N)` == `Threshold for Repayment Mechanism Amount Increase Exceeded`,
         
         check_required_repay_amt=abs(Delt(as.numeric(`Required Repayment Mechanism Amount (O)`),as.numeric(`Required Repayment Mechanism Amount`)))<.0001,
         
         check_action = `Repayment Mechanism Amount Action Required (P)` == `Repayment Mechanism Action Required`,
         
         check_action_lower = action_x == action_y,
         
         check_rev_perc_exp=abs(Delt(as.numeric(`Revenue as Percent of Expenditures (Q)`),as.numeric(`Revenue as Percent of Expenditures`)))<.0001,
         
         check_hi_low_det=`High or Low Revenue ACO Determination (R)`==`High or Low Revenue ACO_ID Determination`)




# summarize comparisons
check_data %>% select(contains("check")) %>% 
  summarise_all(.funs=~(mean(.,na.rm=TRUE)))

investigate = check_data %>% filter(check_action == FALSE)


```




```{r Kevin Compare}
Kevin_data = read_excel("Z:\\pgm output\\ACO-3835 (Finance Prescreening Final Round - Repayment Mechanisms)\\Kevin\\TI00.MSSP.D4MZ.P7B17E1K.DS10S.xlsx", sheet=1)%>% 
  mutate(`ACO Participant TIN` = str_pad(`ACO Participant TIN`, 9, side = c("left"), pad = "0"))



#merge together
check_data<-inner_join(outputFinal,Kevin_data,by=c("ACO ID" = "ACO ID","ACO Participant TIN" = 'ACO Participant TIN',"Benchmark- or Revenue-Based"))
names(check_data)

#This should have zero rows. Datasets should have same ACO/TIN combinations
total_match<-anti_join(outputFinal_CMS,Kevin_data,by=c("ACO ID" = "ACO ID","ACO Participant TIN" = 'ACO Participant TIN',"Benchmark- or Revenue-Based"))


#replace missing and NA with a distinctive value for matching. This is to allow boolean comparisons in situations where data is missing
check_data[,]<-lapply(check_data[,],function(x) ifelse(x=="","-999999999",x))
check_data[,]<-lapply(check_data[,],function(x) ifelse(is.na(x) & is.character(x),"-999999999",x))
check_data[,]<-lapply(check_data[,],function(x) ifelse(is.na(x) & is.numeric(x),-999999999,x))


#make string to lower for comparison
check_data$action_x = gsub(" ", "", tolower(check_data$`Repayment Mechanism Amount Action Required (P)`))
check_data$action_y = gsub(" ", "", tolower(check_data$`Repayment Mechanism Amount Action Required`))


check_data$action_x = gsub("[.]", "", check_data$action_x)
check_data$action_y = gsub("[.]", "", check_data$action_y)
check_data$action_x = gsub("-", "", check_data$action_x)
check_data$action_y = gsub("-", "", check_data$action_y)


library(quantmod)
names(check_data)

check_data<-check_data %>%
  mutate(check_assigned=`2019 Assigned Beneficiaries (A)`==`2019 Assigned Beneficiaries` ,
         
         check_assg_growth=round(`Assignment Growth (B)`,1)==round(`Assignment Growth`,1),
         
         check_proj_2021_benes=if_else(`Projected 2021 Assigned Beneficiaries (C)` == 0, `Projected 2021 Assigned Beneficiaries (C)` == `Projected 2021 Assigned Beneficiaries`, abs(Delt(`Projected 2021 Assigned Beneficiaries (C)`,`Projected 2021 Assigned Beneficiaries`)) < .0001),
         
         check_Doll_per_bene=Delt(as.numeric(`2019 Dollars per Beneficiary (D)`),as.numeric(`2019 Dollars per Beneficiary`))<.0001,
         
         check_trend_dollar=round(as.numeric(`Dollar Trend (E)`),1)==round(as.numeric(`Dollar Trend`),1),
         
         check_Proj_Doll_per_bene=abs(Delt(as.numeric(`Projected 2021 Dollars per Beneficiary (F)`),as.numeric(`Projected 2021 Dollars per Beneficiary`)))<.0001,
         
         check_Proj_Total_Dollars= if_else(`Projected 2021 Total Dollars (G)` == 0, `Projected 2021 Total Dollars (G)` == `Projected 2021 Total Dollars`, abs(Delt(as.numeric(`Projected 2021 Total Dollars (G)`),as.numeric(`Projected 2021 Total Dollars`)))<.0001),
         
         check_req_perc=round(`Required Percentage (H)`,1)==round(`Required Percentage`,1),
         
         check_forecast_repay=if_else(`Forecast Repayment Mechanism Amount (I)` == 0, `Forecast Repayment Mechanism Amount (I)` == `Forecast Repayment Mechanism Amount`,abs(Delt(`Forecast Repayment Mechanism Amount (I)`,`Forecast Repayment Mechanism Amount`))<.0001),
         
         check_risk_track=`Performance-Based Risk Track (J)`==`Performance-Based Risk Track`,
         
         check_existing_repay_amt=round(as.numeric(`Existing Repayment Mechanism Amount (K)`),1)==round(as.numeric(`Existing Repayment Mechanism Amount`),1),
         
         check_Initial_Repay_amt=abs(Delt(as.numeric(`Initial Determined Repayment Mechanism Amount (L)`),as.numeric(`Initial Determined Repayment Mechanism Amount`)))<.0001,
         
         check_track_1plus_ll = `Track 1+ Loss Limit Composition Changed (M)` == `Track 1+ Loss Limit Composition Changed`,
         
         check_met_threshold = `Met Threshold to Update Repayment Mechanism Amount (N)` == `Met Threshold to Update Repayment Mechanism Amount`,
         
         check_required_repay_amt=abs(Delt(as.numeric(`Required Repayment Mechanism Amount (O)`),as.numeric(`Required Repayment Mechanism Amount`)))<.0001,
         
         check_action = `Repayment Mechanism Amount Action Required (P)` == `Repayment Mechanism Amount Action Required`,
         
         check_action_lower = action_x == action_y,
         
         check_rev_perc_exp=abs(Delt(as.numeric(`Revenue as Percent of Expenditures (Q)`),as.numeric(`Revenue as Percent of Expenditures`)))<.0001,
         
         check_hi_low_det=`High or Low Revenue ACO Determination (R)`==`High or Low Revenue ACO Determination`)



# summarize comparisons
check_data %>% select(contains("check")) %>% 
  summarise_all(.funs=~(mean(.,na.rm=TRUE)))


investigate_action = check_data %>% filter(check_action_lower == FALSE )
investigate_thresh = check_data %>% filter(check_met_threshold == FALSE )

investigate_thresh$`ACO ID` %in% investigate_action$`ACO ID`
investigate_action$`ACO ID` %in% investigate_thresh$`ACO ID`


outpinvestigate = output %>% filter(ACO %in% investigate_action$`ACO ID` & TIN == "Total/Average" & METHODOLOGY == "Benchmark-based") %>% mutate(RM_diff = INITIAL_DETER_RM_AMT - ROUND_2_REQ_RM) %>% left_join(investigate_action %>% select(`ACO ID`, `ACO Participant TIN`, `Repayment Mechanism Amount Action Required`, `Benchmark- or Revenue-Based`, `Met Threshold to Update Repayment Mechanism Amount`),by=c("ACO" = "ACO ID", "TIN" = "ACO Participant TIN", "METHODOLOGY" = "Benchmark- or Revenue-Based"))



```


```{r Check Kevin's SAS file}


library(haven)


Kevin_SAS = read_sas("Z:\\pgm output\\ACO-3835 (Finance Prescreening Final Round - Repayment Mechanisms)\\Kevin\\analytic_ds_10s.sas7bdat")
Kevin_SAS$ACO_CATEGORY = NULL


makeVlist <- function(dta) { 
     labels <- sapply(dta, function(x) attr(x, "label"))
      return(unlist(labels))
}

variable_names = makeVlist(Kevin_SAS)


Kevin_SAS = Kevin_SAS %>% 
   mutate(ASSIGNED = as.numeric(round(ASSIGNED, 5)),
         ASSG_GROWTH = as.numeric(round(ASSG_GROWTH, 5)),
         PROJ_ASSIGNED = as.numeric(round(PROJ_ASSIGNED, 0)),
         DOLLAR_PER_BENE  = round(DOLLAR_PER_BENE, 2),
         DOLLAR_TREND = as.numeric(round(DOLLAR_TREND, 5)),
         PROJ_DOLLAR_PER_BENE = as.numeric(round(PROJ_DOLLAR_PER_BENE, 2)),
         PROJ_TOT_DOLLAR = as.numeric(round(PROJ_TOT_DOLLAR, 2)),
         REQ_PCT = as.numeric(round(REQ_PCT, 2)),
         FCST_RM_AMT = as.numeric(round(FCST_RM_AMT, 0)), 
         REPAY_CURRENT = as.numeric(round(REPAY_CURRENT, 0)),
         INITIAL_DETER_RM_AMT = as.numeric(round(INITIAL_DETER_RM_AMT, 0)),
         REQ_RM_AMT = as.numeric(round(REQ_RM_AMT, 0))) 
  
names(Kevin_SAS) = variable_names

Kevin_SAS %>% mutate_if(is.factor, as.character) -> Kevin_SAS





#merge together
check_data<-inner_join(outputFinal,Kevin_SAS,by=c("ACO ID" = "ACO ID","ACO Participant TIN" = 'ACO Participant TIN',"Benchmark- or Revenue-Based"))
names(check_data)

#This should have zero rows. Datasets should have same ACO/TIN combinations
total_match<-anti_join(outputFinal,Kevin_SAS,by=c("ACO ID" = "ACO ID","ACO Participant TIN" = 'ACO Participant TIN',"Benchmark- or Revenue-Based"))


#replace missing and NA with a distinctive value for matching. This is to allow boolean comparisons in situations where data is missing
check_data[,]<-lapply(check_data[,],function(x) ifelse(x=="","-999999999",x))
check_data[,]<-lapply(check_data[,],function(x) ifelse(is.na(x) & is.character(x),"-999999999",x))
check_data[,]<-lapply(check_data[,],function(x) ifelse(is.na(x) & is.numeric(x),-999999999,x))



#make string to lower for comparison
check_data$action_x = gsub(" ", "", tolower(check_data$`Repayment Mechanism Amount Action Required (P)`))
check_data$action_y = gsub(" ", "", tolower(check_data$`Repayment Mechanism Amount Action Required`))
check_data$action_x = gsub("[.]", "", check_data$action_x)
check_data$action_y = gsub("[.]", "", check_data$action_y)
check_data$action_x = gsub("-", "", check_data$action_x)
check_data$action_y = gsub("-", "", check_data$action_y)

library(quantmod)


check_data<-check_data %>% 
  mutate(check_assigned=`2019 Assigned Beneficiaries (A)`==`2019 Assigned Beneficiaries` ,
         
         check_assg_growth=round(`Assignment Growth (B)`,1)==round(`Assignment Growth (B)`,1),
         
         check_proj_2021_benes=if_else(`Projected 2021 Assigned Beneficiaries (C)` == 0, `Projected 2021 Assigned Beneficiaries (C)` == `Projected 2021 Assigned Beneficiaries`, abs(Delt(`Projected 2021 Assigned Beneficiaries (C)`,`Projected 2021 Assigned Beneficiaries`)) < .0001),
         
         check_Doll_per_bene=Delt(as.numeric(`2019 Dollars per Beneficiary (D)`),as.numeric(`2019 Dollars per Beneficiary`))<.0001,
         
         check_trend_dollar=round(as.numeric(`Dollar Trend (E)`),1)==round(as.numeric(`Dollar Trend`),1),
         
         check_Proj_Doll_per_bene=abs(Delt(as.numeric(`Projected 2021 Dollars per Beneficiary (F)`),as.numeric(`Projected 2021 Dollars per Beneficiary`)))<.0001,
         
         check_Proj_Total_Dollars= if_else(`Projected 2021 Total Dollars (G)` == 0, `Projected 2021 Total Dollars (G)` == `Projected 2021 Total Dollars`, abs(Delt(as.numeric(`Projected 2021 Total Dollars (G)`),as.numeric(`Projected 2021 Total Dollars`)))<.0001),
         
         check_req_perc=round(`Required Percentage (H)`,1)==round(`Required Percentage`,1),
         
         check_forecast_repay=if_else(`Forecast Repayment Mechanism Amount (I)` == 0, `Forecast Repayment Mechanism Amount (I)` == `Forecast Repayment Mechanism Amount`,abs(Delt(`Forecast Repayment Mechanism Amount (I)`,`Forecast Repayment Mechanism Amount`))<.0001),
         
         check_risk_track=`Performance-Based Risk Track (J)`==`Performance-Based Risk Track`,
         
         check_existing_repay_amt=round(as.numeric(`Existing Repayment Mechanism Amount (K)`),1)==round(as.numeric(`Existing Repayment Mechanism Amount`),1),
         
         check_Initial_Repay_amt=abs(Delt(as.numeric(`Initial Determined Repayment Mechanism Amount (L)`),as.numeric(`Initial Determined Repayment Mechanism Amount`)))<.0001,
         
         check_track_1plus_ll = `Track 1+ Loss Limit Composition Changed (M)` == `Track 1+ Loss Limit Composition Changed`,
         
         check_met_threshold = `Met Threshold to Update Repayment Mechanism Amount (N)` == `Met Threshold to Update Repayment Mechanism Amount`,
         
         check_required_repay_amt=abs(Delt(as.numeric(`Required Repayment Mechanism Amount (O)`),as.numeric(`Required Repayment Mechanism Amount`)))<.0001,
         
         check_action = `Repayment Mechanism Amount Action Required (P)` == `Repayment Mechanism Amount Action Required`,
         
         check_action_lower = action_x == action_y,
         
         check_rev_perc_exp=abs(Delt(as.numeric(`Revenue as Percent of Expenditures (Q)`),as.numeric(`Revenue as Percent of Expenditures`)))<.0001,
         
         check_hi_low_det=`High or Low Revenue ACO Determination (R)`==`High or Low Revenue ACO Determination`)


# summarize comparisons
check_data %>% select(contains("check")) %>% 
  summarise_all(.funs=~(mean(.,na.rm=TRUE)))


investigate_action = check_data %>% filter(check_action_lower == FALSE )
investigate_thresh = check_data %>% filter(check_met_threshold == FALSE )

investigate_thresh$`ACO ID` %in% investigate_action$`ACO ID`
investigate_action$`ACO ID` %in% investigate_thresh$`ACO ID`


```

```{r Check Final POR}

POR = read_excel("Z:\\participant management\\prescreening\\2021 Prescreening\\Batch G3\\Participation Options Report\\Participation_Options_PY2021_Final_Round_20201019.xlsx", sheet=3)%>% 
  mutate(`ACO Participant TIN` = str_pad(`ACO Participant TIN`, 9, side = c("left"), pad = "0"))



#merge together
check_data<-inner_join(outputFinal,POR,by=c("ACO ID" = "ACO ID","ACO Participant TIN" = 'ACO Participant TIN',"Benchmark- or Revenue-Based"))
names(check_data)

#This should have zero rows. Datasets should have same ACO/TIN combinations
total_match<-anti_join(outputFinal,POR,by=c("ACO ID" = "ACO ID","ACO Participant TIN" = 'ACO Participant TIN',"Benchmark- or Revenue-Based"))
nrow(total_match)

#replace missing and NA with a distinctive value for matching. This is to allow boolean comparisons in situations where data is missing
check_data[,]<-lapply(check_data[,],function(x) ifelse(x=="","-999999999",x))
check_data[,]<-lapply(check_data[,],function(x) ifelse(is.na(x) & is.character(x),"-999999999",x))
check_data[,]<-lapply(check_data[,],function(x) ifelse(is.na(x) & is.numeric(x),-999999999,x))


#make string to lower for comparison
check_data$action_x = gsub(" ", "", tolower(check_data$`Repayment Mechanism Amount Action Required (P)`))
check_data$action_y = gsub(" ", "", tolower(check_data$`Repayment Mechanism Amount Action Required`))
check_data$action_x = gsub("[.]", "", check_data$action_x)
check_data$action_y = gsub("[.]", "", check_data$action_y)
check_data$action_x = gsub("-", "", check_data$action_x)
check_data$action_y = gsub("-", "", check_data$action_y)

library(quantmod)
names(check_data)

check_data<-check_data %>%
  mutate(check_assigned=`2019 Assigned Beneficiaries (A)`==`2019 Assigned Beneficiaries` ,
         
         check_assg_growth=round(`Assignment Growth (B)`,1)==round(`Assignment Growth`,1),
         
         check_proj_2021_benes=if_else(`Projected 2021 Assigned Beneficiaries (C)` == 0, `Projected 2021 Assigned Beneficiaries (C)` == `Projected 2021 Assigned Beneficiaries`, abs(Delt(`Projected 2021 Assigned Beneficiaries (C)`,`Projected 2021 Assigned Beneficiaries`)) < .0001),
         
         check_Doll_per_bene=Delt(as.numeric(`2019 Dollars per Beneficiary (D)`),as.numeric(`2019 Dollars per Beneficiary`))<.0001,
         
         check_trend_dollar=round(as.numeric(`Dollar Trend (E)`),1)==round(as.numeric(`Dollar Trend`),1),
         
         check_Proj_Doll_per_bene=abs(Delt(as.numeric(`Projected 2021 Dollars per Beneficiary (F)`),as.numeric(`Projected 2021 Dollars per Beneficiary`)))<.0001,
         
         check_Proj_Total_Dollars= if_else(`Projected 2021 Total Dollars (G)` == 0, `Projected 2021 Total Dollars (G)` == `Projected 2021 Total Dollars`, abs(Delt(as.numeric(`Projected 2021 Total Dollars (G)`),as.numeric(`Projected 2021 Total Dollars`)))<.0001),
         
         check_req_perc=round(`Required Percentage (H)`,1)==round(`Required Percentage`,1),
         
         check_forecast_repay=if_else(`Forecast Repayment Mechanism Amount (I)` == 0, `Forecast Repayment Mechanism Amount (I)` == `Forecast Repayment Mechanism Amount`,abs(Delt(`Forecast Repayment Mechanism Amount (I)`,`Forecast Repayment Mechanism Amount`))<.0001),
         
         check_risk_track=`Performance-Based Risk Track (J)`==`Performance-Based Risk Track`,
         
         check_existing_repay_amt=Delt(`Existing Repayment Mechanism Amount (K)`,`Existing Repayment Mechanism Amount`) < .000001,
         
         check_Initial_Repay_amt=abs(Delt(as.numeric(`Initial Determined Repayment Mechanism Amount (L)`),as.numeric(`Initial Determined Repayment Mechanism Amount`)))<.0001,
         
         check_track_1plus_ll = `Track 1+ Loss Limit Composition Changed (M)` == `Track 1+ Loss Limit Composition Changed`,
         
         check_met_threshold = `Met Threshold to Update Repayment Mechanism Amount (N)` == `Met Threshold to Update Repayment Mechanism Amount`,
         
         check_required_repay_amt=abs(Delt(as.numeric(`Required Repayment Mechanism Amount (O)`),as.numeric(`Required Repayment Mechanism Amount`)))<.0001,
         
         check_action = `Repayment Mechanism Amount Action Required (P)` == `Repayment Mechanism Amount Action Required`,
         
         check_action_lower = action_x == action_y,
         
         check_rev_perc_exp=abs(Delt(as.numeric(`Revenue as Percent of Expenditures (Q)`),as.numeric(`Revenue as Percent of Expenditures`)))<.0001,
         
         check_hi_low_det=`High or Low Revenue ACO Determination (R)`==`High or Low Revenue ACO Determination`)



# summarize comparisons
check_data %>% select(contains("check")) %>% 
  summarise_all(.funs=~(mean(.,na.rm=TRUE)))

check_data$`Existing Repayment Mechanism Amount`


investigate = check_data %>% filter(check_action_lower == FALSE)
investigate$`Existing Repayment Mechanism Amount`
investigate$`Existing Repayment Mechanism Amount (K)`

#compare summary tab values
Summary_tab = read_excel("Z:\\participant management\\prescreening\\2021 Prescreening\\Batch G3\\Participation Options Report\\Participation_Options_PY2021_Final_Round_20201019.xlsx", sheet=4)
Summary_tab$`Repayment Mechanism Amount (if applicable)` = as.numeric(gsub(",","",Summary_tab$`Repayment Mechanism Amount (if applicable)`))
Summary_tab$`Repayment Mechanism Amount (if applicable)`[is.na(Summary_tab$`Repayment Mechanism Amount (if applicable)`)] = 0


Summary_tab_test = Kevin_SAS %>% filter(`ACO Participant TIN` == "Total/Average" & `Benchmark- or Revenue-Based` == "Benchmark-based") %>% replace_na(list(`Required Repayment Mechanism Amount` = 0))
                                                                                                                                                      
mean(Summary_tab_test$`Required Repayment Mechanism Amount` - Summary_tab$`Repayment Mechanism Amount (if applicable)`)

mean(Summary_tab$`Repayment Mechanism Amount Action Required` == Summary_tab_test$`Repayment Mechanism Amount Action Required`)


```


